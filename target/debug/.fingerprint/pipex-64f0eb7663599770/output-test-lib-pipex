{"$message_type":"diagnostic","message":"can't use a procedural macro from the same crate that defines it","code":null,"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":9061,"byte_end":9068,"line_start":276,"line_end":276,"column_start":7,"column_end":14,"is_primary":true,"text":[{"text":"    #[collect]  ","highlight_start":7,"highlight_end":14}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you can define integration tests in a directory named `tests`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: can't use a procedural macro from the same crate that defines it\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:276:7\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m276\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    #[collect]  \u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: you can define integration tests in a directory named `tests`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"can't use a procedural macro from the same crate that defines it","code":null,"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":9264,"byte_end":9273,"line_start":285,"line_end":285,"column_start":7,"column_end":16,"is_primary":true,"text":[{"text":"    #[fail_fast]","highlight_start":7,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you can define integration tests in a directory named `tests`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: can't use a procedural macro from the same crate that defines it\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:285:7\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m285\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    #[fail_fast]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: you can define integration tests in a directory named `tests`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"`ignore` is ambiguous","code":{"code":"E0659","explanation":"An item usage is ambiguous.\n\nErroneous code example:\n\n```compile_fail,edition2018,E0659\npub mod moon {\n    pub fn foo() {}\n}\n\npub mod earth {\n    pub fn foo() {}\n}\n\nmod collider {\n    pub use crate::moon::*;\n    pub use crate::earth::*;\n}\n\nfn main() {\n    crate::collider::foo(); // ERROR: `foo` is ambiguous\n}\n```\n\nThis error generally appears when two items with the same name are imported into\na module. Here, the `foo` functions are imported and reexported from the\n`collider` module and therefore, when we're using `collider::foo()`, both\nfunctions collide.\n\nTo solve this error, the best solution is generally to keep the path before the\nitem when using it. Example:\n\n```edition2018\npub mod moon {\n    pub fn foo() {}\n}\n\npub mod earth {\n    pub fn foo() {}\n}\n\nmod collider {\n    pub use crate::moon;\n    pub use crate::earth;\n}\n\nfn main() {\n    crate::collider::moon::foo(); // ok!\n    crate::collider::earth::foo(); // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":8862,"byte_end":8868,"line_start":267,"line_end":267,"column_start":7,"column_end":13,"is_primary":true,"text":[{"text":"    #[ignore]","highlight_start":7,"highlight_end":13}],"label":"ambiguous name","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"ambiguous because of a name conflict with a builtin attribute","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"`ignore` could refer to a built-in attribute","code":null,"level":"note","spans":[{"file_name":"src/lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"`ignore` could also refer to the attribute macro imported here","code":null,"level":"note","spans":[{"file_name":"src/lib.rs","byte_start":8791,"byte_end":8799,"line_start":264,"line_end":264,"column_start":9,"column_end":17,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":9,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use `self::ignore` to refer to this attribute macro unambiguously","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0659]\u001b[0m\u001b[0m\u001b[1m: `ignore` is ambiguous\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:267:7\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m267\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    #[ignore]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mambiguous name\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: ambiguous because of a name conflict with a builtin attribute\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `ignore` could refer to a built-in attribute\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `ignore` could also refer to the attribute macro imported here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:264:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m264\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    use super::*;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: use `self::ignore` to refer to this attribute macro unambiguously\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":7185,"byte_end":7200,"line_start":213,"line_end":213,"column_start":63,"column_end":78,"is_primary":true,"text":[{"text":"                    Ok($crate::IgnoreStrategy::handle_results(futures_results))","highlight_start":63,"highlight_end":78}],"label":"expected `Vec<Result<_, _>>`, found `Vec<impl Future<Output = ...>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":6510,"byte_end":6566,"line_start":198,"line_end":198,"column_start":13,"column_end":69,"is_primary":false,"text":[{"text":"            pipex!(@async_with_error_handling input, $var, $fn_call)","highlight_start":13,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":5600,"byte_end":5640,"line_start":174,"line_end":174,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":9539,"byte_end":9664,"line_start":296,"line_end":299,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 3, 4, 5]","highlight_start":1,"highlight_end":32},{"text":"            => async? |x| process_with_ignore(x)  // Natural function call!","highlight_start":1,"highlight_end":76},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":7146,"byte_end":7184,"line_start":213,"line_end":213,"column_start":24,"column_end":62,"is_primary":false,"text":[{"text":"                    Ok($crate::IgnoreStrategy::handle_results(futures_results))","highlight_start":24,"highlight_end":62}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":6510,"byte_end":6566,"line_start":198,"line_end":198,"column_start":13,"column_end":69,"is_primary":false,"text":[{"text":"            pipex!(@async_with_error_handling input, $var, $fn_call)","highlight_start":13,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":5600,"byte_end":5640,"line_start":174,"line_end":174,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":9539,"byte_end":9664,"line_start":296,"line_end":299,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 3, 4, 5]","highlight_start":1,"highlight_end":32},{"text":"            => async? |x| process_with_ignore(x)  // Natural function call!","highlight_start":1,"highlight_end":76},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected struct `Vec<Result<_, _>>`\n   found struct `Vec<impl futures::Future<Output = Result<i32, std::string::String>>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"src/lib.rs","byte_start":1606,"byte_end":1613,"line_start":50,"line_end":50,"column_start":23,"column_end":30,"is_primary":false,"text":[{"text":"    fn handle_results(results: Vec<Result<T, E>>) -> Self::Output;","highlight_start":23,"highlight_end":30}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":1591,"byte_end":1605,"line_start":50,"line_end":50,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"    fn handle_results(results: Vec<Result<T, E>>) -> Self::Output;","highlight_start":8,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:213:63\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m213\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                    Ok($crate::IgnoreStrategy::handle_results(futures_results))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `Vec<Result<_, _>>`, found `Vec<impl Future<Output = ...>>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this function are incorrect\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m296\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        let result = pipex!(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m ______________________-\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m297\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            vec![1, 2, 3, 4, 5]\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m298\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            => async? |x| process_with_ignore(x)  // Natural function call!\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m299\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        );\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected struct `Vec<\u001b[0m\u001b[0m\u001b[1m\u001b[35mResult<_, _>\u001b[0m\u001b[0m>`\u001b[0m\n\u001b[0m               found struct `Vec<\u001b[0m\u001b[0m\u001b[1m\u001b[35mimpl futures::Future<Output = Result<i32, std::string::String>>\u001b[0m\u001b[0m>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:50:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m50\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn handle_results(results: Vec<Result<T, E>>) -> Self::Output;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `pipex` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":7501,"byte_end":7516,"line_start":219,"line_end":219,"column_start":64,"column_end":79,"is_primary":true,"text":[{"text":"                    Ok($crate::CollectStrategy::handle_results(futures_results))","highlight_start":64,"highlight_end":79}],"label":"expected `Vec<Result<_, _>>`, found `Vec<impl Future<Output = ...>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":6510,"byte_end":6566,"line_start":198,"line_end":198,"column_start":13,"column_end":69,"is_primary":false,"text":[{"text":"            pipex!(@async_with_error_handling input, $var, $fn_call)","highlight_start":13,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":5600,"byte_end":5640,"line_start":174,"line_end":174,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":9539,"byte_end":9664,"line_start":296,"line_end":299,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 3, 4, 5]","highlight_start":1,"highlight_end":32},{"text":"            => async? |x| process_with_ignore(x)  // Natural function call!","highlight_start":1,"highlight_end":76},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":7461,"byte_end":7500,"line_start":219,"line_end":219,"column_start":24,"column_end":63,"is_primary":false,"text":[{"text":"                    Ok($crate::CollectStrategy::handle_results(futures_results))","highlight_start":24,"highlight_end":63}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":6510,"byte_end":6566,"line_start":198,"line_end":198,"column_start":13,"column_end":69,"is_primary":false,"text":[{"text":"            pipex!(@async_with_error_handling input, $var, $fn_call)","highlight_start":13,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":5600,"byte_end":5640,"line_start":174,"line_end":174,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":9539,"byte_end":9664,"line_start":296,"line_end":299,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 3, 4, 5]","highlight_start":1,"highlight_end":32},{"text":"            => async? |x| process_with_ignore(x)  // Natural function call!","highlight_start":1,"highlight_end":76},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected struct `Vec<Result<_, _>>`\n   found struct `Vec<impl futures::Future<Output = Result<i32, std::string::String>>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"src/lib.rs","byte_start":1606,"byte_end":1613,"line_start":50,"line_end":50,"column_start":23,"column_end":30,"is_primary":false,"text":[{"text":"    fn handle_results(results: Vec<Result<T, E>>) -> Self::Output;","highlight_start":23,"highlight_end":30}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":1591,"byte_end":1605,"line_start":50,"line_end":50,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"    fn handle_results(results: Vec<Result<T, E>>) -> Self::Output;","highlight_start":8,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:219:64\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m219\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                    Ok($crate::CollectStrategy::handle_results(futures_results))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `Vec<Result<_, _>>`, found `Vec<impl Future<Output = ...>>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this function are incorrect\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m296\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        let result = pipex!(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m ______________________-\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m297\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            vec![1, 2, 3, 4, 5]\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m298\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            => async? |x| process_with_ignore(x)  // Natural function call!\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m299\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        );\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected struct `Vec<\u001b[0m\u001b[0m\u001b[1m\u001b[35mResult<_, _>\u001b[0m\u001b[0m>`\u001b[0m\n\u001b[0m               found struct `Vec<\u001b[0m\u001b[0m\u001b[1m\u001b[35mimpl futures::Future<Output = Result<i32, std::string::String>>\u001b[0m\u001b[0m>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:50:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m50\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn handle_results(results: Vec<Result<T, E>>) -> Self::Output;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `pipex` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"`match` arms have incompatible types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":8011,"byte_end":8022,"line_start":231,"line_end":231,"column_start":21,"column_end":32,"is_primary":true,"text":[{"text":"                    Ok(results)","highlight_start":21,"highlight_end":32}],"label":"expected `Result<Vec<Result<_, _>>, _>`, found `Result<Vec<i32>, _>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":6510,"byte_end":6566,"line_start":198,"line_end":198,"column_start":13,"column_end":69,"is_primary":false,"text":[{"text":"            pipex!(@async_with_error_handling input, $var, $fn_call)","highlight_start":13,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":5600,"byte_end":5640,"line_start":174,"line_end":174,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":9539,"byte_end":9664,"line_start":296,"line_end":299,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 3, 4, 5]","highlight_start":1,"highlight_end":32},{"text":"            => async? |x| process_with_ignore(x)  // Natural function call!","highlight_start":1,"highlight_end":76},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":7143,"byte_end":7202,"line_start":213,"line_end":213,"column_start":21,"column_end":80,"is_primary":false,"text":[{"text":"                    Ok($crate::IgnoreStrategy::handle_results(futures_results))","highlight_start":21,"highlight_end":80}],"label":"this is found to be of type `Result<Vec<Result<_, _>>, _>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":6510,"byte_end":6566,"line_start":198,"line_end":198,"column_start":13,"column_end":69,"is_primary":false,"text":[{"text":"            pipex!(@async_with_error_handling input, $var, $fn_call)","highlight_start":13,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":5600,"byte_end":5640,"line_start":174,"line_end":174,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":9539,"byte_end":9664,"line_start":296,"line_end":299,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 3, 4, 5]","highlight_start":1,"highlight_end":32},{"text":"            => async? |x| process_with_ignore(x)  // Natural function call!","highlight_start":1,"highlight_end":76},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":7458,"byte_end":7518,"line_start":219,"line_end":219,"column_start":21,"column_end":81,"is_primary":false,"text":[{"text":"                    Ok($crate::CollectStrategy::handle_results(futures_results))","highlight_start":21,"highlight_end":81}],"label":"this is found to be of type `Result<Vec<Result<_, _>>, _>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":6510,"byte_end":6566,"line_start":198,"line_end":198,"column_start":13,"column_end":69,"is_primary":false,"text":[{"text":"            pipex!(@async_with_error_handling input, $var, $fn_call)","highlight_start":13,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":5600,"byte_end":5640,"line_start":174,"line_end":174,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":9539,"byte_end":9664,"line_start":296,"line_end":299,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 3, 4, 5]","highlight_start":1,"highlight_end":32},{"text":"            => async? |x| process_with_ignore(x)  // Natural function call!","highlight_start":1,"highlight_end":76},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":6891,"byte_end":8054,"line_start":208,"line_end":233,"column_start":13,"column_end":14,"is_primary":false,"text":[{"text":"            match strategy {","highlight_start":13,"highlight_end":29},{"text":"                \"ignore\" => {","highlight_start":1,"highlight_end":30},{"text":"                    let futures_results = $crate::futures::future::join_all(","highlight_start":1,"highlight_end":77},{"text":"                        $input.into_iter().map(|$var| async move { $fn_call })","highlight_start":1,"highlight_end":79},{"text":"                    ).await;","highlight_start":1,"highlight_end":29},{"text":"                    Ok($crate::IgnoreStrategy::handle_results(futures_results))","highlight_start":1,"highlight_end":80},{"text":"                },","highlight_start":1,"highlight_end":19},{"text":"                \"collect\" => {","highlight_start":1,"highlight_end":31},{"text":"                    let futures_results = $crate::futures::future::join_all(","highlight_start":1,"highlight_end":77},{"text":"                        $input.into_iter().map(|$var| async move { $fn_call })","highlight_start":1,"highlight_end":79},{"text":"                    ).await;","highlight_start":1,"highlight_end":29},{"text":"                    Ok($crate::CollectStrategy::handle_results(futures_results))","highlight_start":1,"highlight_end":81},{"text":"                },","highlight_start":1,"highlight_end":19},{"text":"                _ => {","highlight_start":1,"highlight_end":23},{"text":"                    // Default: fail_fast - process sequentially to truly fail fast","highlight_start":1,"highlight_end":84},{"text":"                    let mut results = Vec::new();","highlight_start":1,"highlight_end":50},{"text":"                    for item in $input {","highlight_start":1,"highlight_end":41},{"text":"                        let $var = item;","highlight_start":1,"highlight_end":41},{"text":"                        match { $fn_call }.await {","highlight_start":1,"highlight_end":51},{"text":"                            Ok(value) => results.push(value),","highlight_start":1,"highlight_end":62},{"text":"                            Err(e) => return Err(e),","highlight_start":1,"highlight_end":53},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    Ok(results)","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14}],"label":"`match` arms have incompatible types","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":6510,"byte_end":6566,"line_start":198,"line_end":198,"column_start":13,"column_end":69,"is_primary":false,"text":[{"text":"            pipex!(@async_with_error_handling input, $var, $fn_call)","highlight_start":13,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":5600,"byte_end":5640,"line_start":174,"line_end":174,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":9539,"byte_end":9664,"line_start":296,"line_end":299,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 3, 4, 5]","highlight_start":1,"highlight_end":32},{"text":"            => async? |x| process_with_ignore(x)  // Natural function call!","highlight_start":1,"highlight_end":76},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected enum `Result<Vec<Result<_, _>>, _>`\n   found enum `Result<Vec<i32>, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"try wrapping the expression in `Err`","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":8011,"byte_end":8011,"line_start":231,"line_end":231,"column_start":21,"column_end":21,"is_primary":true,"text":[{"text":"                    Ok(results)","highlight_start":21,"highlight_end":21}],"label":null,"suggested_replacement":"Err(","suggestion_applicability":"MaybeIncorrect","expansion":{"span":{"file_name":"src/lib.rs","byte_start":6510,"byte_end":6566,"line_start":198,"line_end":198,"column_start":13,"column_end":69,"is_primary":false,"text":[{"text":"            pipex!(@async_with_error_handling input, $var, $fn_call)","highlight_start":13,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":5600,"byte_end":5640,"line_start":174,"line_end":174,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":9539,"byte_end":9664,"line_start":296,"line_end":299,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 3, 4, 5]","highlight_start":1,"highlight_end":32},{"text":"            => async? |x| process_with_ignore(x)  // Natural function call!","highlight_start":1,"highlight_end":76},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":8022,"byte_end":8022,"line_start":231,"line_end":231,"column_start":32,"column_end":32,"is_primary":true,"text":[{"text":"                    Ok(results)","highlight_start":32,"highlight_end":32}],"label":null,"suggested_replacement":")","suggestion_applicability":"MaybeIncorrect","expansion":{"span":{"file_name":"src/lib.rs","byte_start":6510,"byte_end":6566,"line_start":198,"line_end":198,"column_start":13,"column_end":69,"is_primary":false,"text":[{"text":"            pipex!(@async_with_error_handling input, $var, $fn_call)","highlight_start":13,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":5600,"byte_end":5640,"line_start":174,"line_end":174,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":9539,"byte_end":9664,"line_start":296,"line_end":299,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 3, 4, 5]","highlight_start":1,"highlight_end":32},{"text":"            => async? |x| process_with_ignore(x)  // Natural function call!","highlight_start":1,"highlight_end":76},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: `match` arms have incompatible types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:231:21\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m208\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m            match strategy {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m209\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                \"ignore\" => {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m210\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    let futures_results = $crate::futures::future::join_all(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m211\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        $input.into_iter().map(|$var| async move { $fn_call })\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m212\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    ).await;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m213\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    Ok($crate::IgnoreStrategy::handle_results(futures_results))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis is found to be of type `Result<Vec<Result<_, _>>, _>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m219\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    Ok($crate::CollectStrategy::handle_results(futures_results))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis is found to be of type `Result<Vec<Result<_, _>>, _>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m231\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    Ok(results)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `Result<Vec<Result<_, _>>, _>`, found `Result<Vec<i32>, _>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m232\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m233\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_____________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m`match` arms have incompatible types\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m296\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        let result = pipex!(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m ______________________-\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m297\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            vec![1, 2, 3, 4, 5]\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m298\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            => async? |x| process_with_ignore(x)  // Natural function call!\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m299\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        );\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected enum `Result<Vec<\u001b[0m\u001b[0m\u001b[1m\u001b[35mResult<_, _>\u001b[0m\u001b[0m>, \u001b[0m\u001b[0m\u001b[1m\u001b[35m_\u001b[0m\u001b[0m>`\u001b[0m\n\u001b[0m               found enum `Result<Vec<\u001b[0m\u001b[0m\u001b[1m\u001b[35mi32\u001b[0m\u001b[0m>, \u001b[0m\u001b[0m\u001b[1m\u001b[35m_\u001b[0m\u001b[0m>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `pipex` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: try wrapping the expression in `Err`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m231\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[38;5;10mErr(\u001b[0m\u001b[0mOk(results)\u001b[0m\u001b[0m\u001b[38;5;10m)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[38;5;10m++++\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"can't compare `Vec<_>` with `Result<Vec<{integer}>, _>`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/dransy/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1485,"byte_end":1487,"line_start":46,"line_end":46,"column_start":32,"column_end":34,"is_primary":true,"text":[{"text":"                if !(*left_val == *right_val) {","highlight_start":32,"highlight_end":34}],"label":"no implementation for `Vec<_> == Result<Vec<{integer}>, _>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":9742,"byte_end":9783,"line_start":302,"line_end":302,"column_start":9,"column_end":50,"is_primary":false,"text":[{"text":"        assert_eq!(result, Ok(vec![2, 4, 8, 10]));","highlight_start":9,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"assert_eq!","def_site_span":{"file_name":"/Users/dransy/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1315,"byte_end":1337,"line_start":42,"line_end":42,"column_start":1,"column_end":23,"is_primary":false,"text":[{"text":"macro_rules! assert_eq {","highlight_start":1,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `PartialEq<Result<Vec<{integer}>, _>>` is not implemented for `Vec<_>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `PartialEq<Rhs>`:\n  `Vec<T, A1>` implements `PartialEq<Vec<U, A2>>`\n  `Vec<T, A>` implements `PartialEq<&[U; N]>`\n  `Vec<T, A>` implements `PartialEq<&[U]>`\n  `Vec<T, A>` implements `PartialEq<&mut [U]>`\n  `Vec<T, A>` implements `PartialEq<[U; N]>`\n  `Vec<T, A>` implements `PartialEq<[U]>`\n  `Vec<u8>` implements `PartialEq<ByteString>`\n  `Vec<u8>` implements `PartialEq<bytes::bytes::Bytes>`\nand 2 others","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: can't compare `Vec<_>` with `Result<Vec<{integer}>, _>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:302:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m302\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        assert_eq!(result, Ok(vec![2, 4, 8, 10]));\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mno implementation for `Vec<_> == Result<Vec<{integer}>, _>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `PartialEq<Result<Vec<{integer}>, _>>` is not implemented for `Vec<_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `PartialEq<Rhs>`:\u001b[0m\n\u001b[0m              `Vec<T, A1>` implements `PartialEq<Vec<U, A2>>`\u001b[0m\n\u001b[0m              `Vec<T, A>` implements `PartialEq<&[U; N]>`\u001b[0m\n\u001b[0m              `Vec<T, A>` implements `PartialEq<&[U]>`\u001b[0m\n\u001b[0m              `Vec<T, A>` implements `PartialEq<&mut [U]>`\u001b[0m\n\u001b[0m              `Vec<T, A>` implements `PartialEq<[U; N]>`\u001b[0m\n\u001b[0m              `Vec<T, A>` implements `PartialEq<[U]>`\u001b[0m\n\u001b[0m              `Vec<u8>` implements `PartialEq<ByteString>`\u001b[0m\n\u001b[0m              `Vec<u8>` implements `PartialEq<bytes::bytes::Bytes>`\u001b[0m\n\u001b[0m            and 2 others\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":7185,"byte_end":7200,"line_start":213,"line_end":213,"column_start":63,"column_end":78,"is_primary":true,"text":[{"text":"                    Ok($crate::IgnoreStrategy::handle_results(futures_results))","highlight_start":63,"highlight_end":78}],"label":"expected `Vec<Result<_, _>>`, found `Vec<impl Future<Output = ...>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":6510,"byte_end":6566,"line_start":198,"line_end":198,"column_start":13,"column_end":69,"is_primary":false,"text":[{"text":"            pipex!(@async_with_error_handling input, $var, $fn_call)","highlight_start":13,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":5600,"byte_end":5640,"line_start":174,"line_end":174,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":9866,"byte_end":9989,"line_start":307,"line_end":310,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 3, 4]","highlight_start":1,"highlight_end":29},{"text":"            => async? |x| process_with_collect(x)  // Natural function call!","highlight_start":1,"highlight_end":77},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":7146,"byte_end":7184,"line_start":213,"line_end":213,"column_start":24,"column_end":62,"is_primary":false,"text":[{"text":"                    Ok($crate::IgnoreStrategy::handle_results(futures_results))","highlight_start":24,"highlight_end":62}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":6510,"byte_end":6566,"line_start":198,"line_end":198,"column_start":13,"column_end":69,"is_primary":false,"text":[{"text":"            pipex!(@async_with_error_handling input, $var, $fn_call)","highlight_start":13,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":5600,"byte_end":5640,"line_start":174,"line_end":174,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":9866,"byte_end":9989,"line_start":307,"line_end":310,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 3, 4]","highlight_start":1,"highlight_end":29},{"text":"            => async? |x| process_with_collect(x)  // Natural function call!","highlight_start":1,"highlight_end":77},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected struct `Vec<Result<_, _>>`\n   found struct `Vec<impl futures::Future<Output = Result<i32, std::string::String>>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"src/lib.rs","byte_start":1606,"byte_end":1613,"line_start":50,"line_end":50,"column_start":23,"column_end":30,"is_primary":false,"text":[{"text":"    fn handle_results(results: Vec<Result<T, E>>) -> Self::Output;","highlight_start":23,"highlight_end":30}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":1591,"byte_end":1605,"line_start":50,"line_end":50,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"    fn handle_results(results: Vec<Result<T, E>>) -> Self::Output;","highlight_start":8,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:213:63\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m213\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                    Ok($crate::IgnoreStrategy::handle_results(futures_results))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `Vec<Result<_, _>>`, found `Vec<impl Future<Output = ...>>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this function are incorrect\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m307\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        let result = pipex!(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m ______________________-\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m308\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            vec![1, 2, 3, 4]\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m309\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            => async? |x| process_with_collect(x)  // Natural function call!\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m310\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        );\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected struct `Vec<\u001b[0m\u001b[0m\u001b[1m\u001b[35mResult<_, _>\u001b[0m\u001b[0m>`\u001b[0m\n\u001b[0m               found struct `Vec<\u001b[0m\u001b[0m\u001b[1m\u001b[35mimpl futures::Future<Output = Result<i32, std::string::String>>\u001b[0m\u001b[0m>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:50:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m50\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn handle_results(results: Vec<Result<T, E>>) -> Self::Output;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `pipex` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":7501,"byte_end":7516,"line_start":219,"line_end":219,"column_start":64,"column_end":79,"is_primary":true,"text":[{"text":"                    Ok($crate::CollectStrategy::handle_results(futures_results))","highlight_start":64,"highlight_end":79}],"label":"expected `Vec<Result<_, _>>`, found `Vec<impl Future<Output = ...>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":6510,"byte_end":6566,"line_start":198,"line_end":198,"column_start":13,"column_end":69,"is_primary":false,"text":[{"text":"            pipex!(@async_with_error_handling input, $var, $fn_call)","highlight_start":13,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":5600,"byte_end":5640,"line_start":174,"line_end":174,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":9866,"byte_end":9989,"line_start":307,"line_end":310,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 3, 4]","highlight_start":1,"highlight_end":29},{"text":"            => async? |x| process_with_collect(x)  // Natural function call!","highlight_start":1,"highlight_end":77},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":7461,"byte_end":7500,"line_start":219,"line_end":219,"column_start":24,"column_end":63,"is_primary":false,"text":[{"text":"                    Ok($crate::CollectStrategy::handle_results(futures_results))","highlight_start":24,"highlight_end":63}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":6510,"byte_end":6566,"line_start":198,"line_end":198,"column_start":13,"column_end":69,"is_primary":false,"text":[{"text":"            pipex!(@async_with_error_handling input, $var, $fn_call)","highlight_start":13,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":5600,"byte_end":5640,"line_start":174,"line_end":174,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":9866,"byte_end":9989,"line_start":307,"line_end":310,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 3, 4]","highlight_start":1,"highlight_end":29},{"text":"            => async? |x| process_with_collect(x)  // Natural function call!","highlight_start":1,"highlight_end":77},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected struct `Vec<Result<_, _>>`\n   found struct `Vec<impl futures::Future<Output = Result<i32, std::string::String>>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"src/lib.rs","byte_start":1606,"byte_end":1613,"line_start":50,"line_end":50,"column_start":23,"column_end":30,"is_primary":false,"text":[{"text":"    fn handle_results(results: Vec<Result<T, E>>) -> Self::Output;","highlight_start":23,"highlight_end":30}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":1591,"byte_end":1605,"line_start":50,"line_end":50,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"    fn handle_results(results: Vec<Result<T, E>>) -> Self::Output;","highlight_start":8,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:219:64\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m219\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                    Ok($crate::CollectStrategy::handle_results(futures_results))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `Vec<Result<_, _>>`, found `Vec<impl Future<Output = ...>>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this function are incorrect\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m307\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        let result = pipex!(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m ______________________-\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m308\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            vec![1, 2, 3, 4]\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m309\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            => async? |x| process_with_collect(x)  // Natural function call!\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m310\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        );\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected struct `Vec<\u001b[0m\u001b[0m\u001b[1m\u001b[35mResult<_, _>\u001b[0m\u001b[0m>`\u001b[0m\n\u001b[0m               found struct `Vec<\u001b[0m\u001b[0m\u001b[1m\u001b[35mimpl futures::Future<Output = Result<i32, std::string::String>>\u001b[0m\u001b[0m>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:50:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m50\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn handle_results(results: Vec<Result<T, E>>) -> Self::Output;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `pipex` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"`match` arms have incompatible types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":8011,"byte_end":8022,"line_start":231,"line_end":231,"column_start":21,"column_end":32,"is_primary":true,"text":[{"text":"                    Ok(results)","highlight_start":21,"highlight_end":32}],"label":"expected `Result<Vec<Result<_, _>>, _>`, found `Result<Vec<i32>, _>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":6510,"byte_end":6566,"line_start":198,"line_end":198,"column_start":13,"column_end":69,"is_primary":false,"text":[{"text":"            pipex!(@async_with_error_handling input, $var, $fn_call)","highlight_start":13,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":5600,"byte_end":5640,"line_start":174,"line_end":174,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":9866,"byte_end":9989,"line_start":307,"line_end":310,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 3, 4]","highlight_start":1,"highlight_end":29},{"text":"            => async? |x| process_with_collect(x)  // Natural function call!","highlight_start":1,"highlight_end":77},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":7143,"byte_end":7202,"line_start":213,"line_end":213,"column_start":21,"column_end":80,"is_primary":false,"text":[{"text":"                    Ok($crate::IgnoreStrategy::handle_results(futures_results))","highlight_start":21,"highlight_end":80}],"label":"this is found to be of type `Result<Vec<Result<_, _>>, _>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":6510,"byte_end":6566,"line_start":198,"line_end":198,"column_start":13,"column_end":69,"is_primary":false,"text":[{"text":"            pipex!(@async_with_error_handling input, $var, $fn_call)","highlight_start":13,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":5600,"byte_end":5640,"line_start":174,"line_end":174,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":9866,"byte_end":9989,"line_start":307,"line_end":310,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 3, 4]","highlight_start":1,"highlight_end":29},{"text":"            => async? |x| process_with_collect(x)  // Natural function call!","highlight_start":1,"highlight_end":77},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":7458,"byte_end":7518,"line_start":219,"line_end":219,"column_start":21,"column_end":81,"is_primary":false,"text":[{"text":"                    Ok($crate::CollectStrategy::handle_results(futures_results))","highlight_start":21,"highlight_end":81}],"label":"this is found to be of type `Result<Vec<Result<_, _>>, _>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":6510,"byte_end":6566,"line_start":198,"line_end":198,"column_start":13,"column_end":69,"is_primary":false,"text":[{"text":"            pipex!(@async_with_error_handling input, $var, $fn_call)","highlight_start":13,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":5600,"byte_end":5640,"line_start":174,"line_end":174,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":9866,"byte_end":9989,"line_start":307,"line_end":310,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 3, 4]","highlight_start":1,"highlight_end":29},{"text":"            => async? |x| process_with_collect(x)  // Natural function call!","highlight_start":1,"highlight_end":77},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":6891,"byte_end":8054,"line_start":208,"line_end":233,"column_start":13,"column_end":14,"is_primary":false,"text":[{"text":"            match strategy {","highlight_start":13,"highlight_end":29},{"text":"                \"ignore\" => {","highlight_start":1,"highlight_end":30},{"text":"                    let futures_results = $crate::futures::future::join_all(","highlight_start":1,"highlight_end":77},{"text":"                        $input.into_iter().map(|$var| async move { $fn_call })","highlight_start":1,"highlight_end":79},{"text":"                    ).await;","highlight_start":1,"highlight_end":29},{"text":"                    Ok($crate::IgnoreStrategy::handle_results(futures_results))","highlight_start":1,"highlight_end":80},{"text":"                },","highlight_start":1,"highlight_end":19},{"text":"                \"collect\" => {","highlight_start":1,"highlight_end":31},{"text":"                    let futures_results = $crate::futures::future::join_all(","highlight_start":1,"highlight_end":77},{"text":"                        $input.into_iter().map(|$var| async move { $fn_call })","highlight_start":1,"highlight_end":79},{"text":"                    ).await;","highlight_start":1,"highlight_end":29},{"text":"                    Ok($crate::CollectStrategy::handle_results(futures_results))","highlight_start":1,"highlight_end":81},{"text":"                },","highlight_start":1,"highlight_end":19},{"text":"                _ => {","highlight_start":1,"highlight_end":23},{"text":"                    // Default: fail_fast - process sequentially to truly fail fast","highlight_start":1,"highlight_end":84},{"text":"                    let mut results = Vec::new();","highlight_start":1,"highlight_end":50},{"text":"                    for item in $input {","highlight_start":1,"highlight_end":41},{"text":"                        let $var = item;","highlight_start":1,"highlight_end":41},{"text":"                        match { $fn_call }.await {","highlight_start":1,"highlight_end":51},{"text":"                            Ok(value) => results.push(value),","highlight_start":1,"highlight_end":62},{"text":"                            Err(e) => return Err(e),","highlight_start":1,"highlight_end":53},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    Ok(results)","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14}],"label":"`match` arms have incompatible types","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":6510,"byte_end":6566,"line_start":198,"line_end":198,"column_start":13,"column_end":69,"is_primary":false,"text":[{"text":"            pipex!(@async_with_error_handling input, $var, $fn_call)","highlight_start":13,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":5600,"byte_end":5640,"line_start":174,"line_end":174,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":9866,"byte_end":9989,"line_start":307,"line_end":310,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 3, 4]","highlight_start":1,"highlight_end":29},{"text":"            => async? |x| process_with_collect(x)  // Natural function call!","highlight_start":1,"highlight_end":77},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected enum `Result<Vec<Result<_, _>>, _>`\n   found enum `Result<Vec<i32>, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"try wrapping the expression in `Err`","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":8011,"byte_end":8011,"line_start":231,"line_end":231,"column_start":21,"column_end":21,"is_primary":true,"text":[{"text":"                    Ok(results)","highlight_start":21,"highlight_end":21}],"label":null,"suggested_replacement":"Err(","suggestion_applicability":"MaybeIncorrect","expansion":{"span":{"file_name":"src/lib.rs","byte_start":6510,"byte_end":6566,"line_start":198,"line_end":198,"column_start":13,"column_end":69,"is_primary":false,"text":[{"text":"            pipex!(@async_with_error_handling input, $var, $fn_call)","highlight_start":13,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":5600,"byte_end":5640,"line_start":174,"line_end":174,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":9866,"byte_end":9989,"line_start":307,"line_end":310,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 3, 4]","highlight_start":1,"highlight_end":29},{"text":"            => async? |x| process_with_collect(x)  // Natural function call!","highlight_start":1,"highlight_end":77},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":8022,"byte_end":8022,"line_start":231,"line_end":231,"column_start":32,"column_end":32,"is_primary":true,"text":[{"text":"                    Ok(results)","highlight_start":32,"highlight_end":32}],"label":null,"suggested_replacement":")","suggestion_applicability":"MaybeIncorrect","expansion":{"span":{"file_name":"src/lib.rs","byte_start":6510,"byte_end":6566,"line_start":198,"line_end":198,"column_start":13,"column_end":69,"is_primary":false,"text":[{"text":"            pipex!(@async_with_error_handling input, $var, $fn_call)","highlight_start":13,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":5600,"byte_end":5640,"line_start":174,"line_end":174,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":9866,"byte_end":9989,"line_start":307,"line_end":310,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 3, 4]","highlight_start":1,"highlight_end":29},{"text":"            => async? |x| process_with_collect(x)  // Natural function call!","highlight_start":1,"highlight_end":77},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: `match` arms have incompatible types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:231:21\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m208\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m            match strategy {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m209\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                \"ignore\" => {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m210\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    let futures_results = $crate::futures::future::join_all(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m211\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        $input.into_iter().map(|$var| async move { $fn_call })\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m212\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    ).await;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m213\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    Ok($crate::IgnoreStrategy::handle_results(futures_results))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis is found to be of type `Result<Vec<Result<_, _>>, _>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m219\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    Ok($crate::CollectStrategy::handle_results(futures_results))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis is found to be of type `Result<Vec<Result<_, _>>, _>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m231\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    Ok(results)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `Result<Vec<Result<_, _>>, _>`, found `Result<Vec<i32>, _>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m232\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m233\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_____________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m`match` arms have incompatible types\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m307\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        let result = pipex!(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m ______________________-\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m308\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            vec![1, 2, 3, 4]\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m309\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            => async? |x| process_with_collect(x)  // Natural function call!\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m310\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        );\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected enum `Result<Vec<\u001b[0m\u001b[0m\u001b[1m\u001b[35mResult<_, _>\u001b[0m\u001b[0m>, \u001b[0m\u001b[0m\u001b[1m\u001b[35m_\u001b[0m\u001b[0m>`\u001b[0m\n\u001b[0m               found enum `Result<Vec<\u001b[0m\u001b[0m\u001b[1m\u001b[35mi32\u001b[0m\u001b[0m>, \u001b[0m\u001b[0m\u001b[1m\u001b[35m_\u001b[0m\u001b[0m>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `pipex` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: try wrapping the expression in `Err`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m231\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[38;5;10mErr(\u001b[0m\u001b[0mOk(results)\u001b[0m\u001b[0m\u001b[38;5;10m)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[38;5;10m++++\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":10007,"byte_end":10018,"line_start":312,"line_end":312,"column_start":16,"column_end":27,"is_primary":true,"text":[{"text":"        if let Ok(results) = result {","highlight_start":16,"highlight_end":27}],"label":"expected `Vec<_>`, found `Result<_, _>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":10021,"byte_end":10027,"line_start":312,"line_end":312,"column_start":30,"column_end":36,"is_primary":false,"text":[{"text":"        if let Ok(results) = result {","highlight_start":30,"highlight_end":36}],"label":"this expression has type `Vec<_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Vec<_>`\n     found enum `Result<_, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:312:16\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m312\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        if let Ok(results) = result {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis expression has type `Vec<_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `Vec<_>`, found `Result<_, _>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected struct `\u001b[0m\u001b[0m\u001b[1m\u001b[35mVec<_>\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m                 found enum `\u001b[0m\u001b[0m\u001b[1m\u001b[35mResult<_, _>\u001b[0m\u001b[0m`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":7185,"byte_end":7200,"line_start":213,"line_end":213,"column_start":63,"column_end":78,"is_primary":true,"text":[{"text":"                    Ok($crate::IgnoreStrategy::handle_results(futures_results))","highlight_start":63,"highlight_end":78}],"label":"expected `Vec<Result<_, _>>`, found `Vec<impl Future<Output = ...>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":6510,"byte_end":6566,"line_start":198,"line_end":198,"column_start":13,"column_end":69,"is_primary":false,"text":[{"text":"            pipex!(@async_with_error_handling input, $var, $fn_call)","highlight_start":13,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":5600,"byte_end":5640,"line_start":174,"line_end":174,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":10362,"byte_end":10490,"line_start":323,"line_end":326,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 3, 4, 5]","highlight_start":1,"highlight_end":32},{"text":"            => async? |x| process_with_fail_fast(x)  // Natural function call!","highlight_start":1,"highlight_end":79},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":7146,"byte_end":7184,"line_start":213,"line_end":213,"column_start":24,"column_end":62,"is_primary":false,"text":[{"text":"                    Ok($crate::IgnoreStrategy::handle_results(futures_results))","highlight_start":24,"highlight_end":62}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":6510,"byte_end":6566,"line_start":198,"line_end":198,"column_start":13,"column_end":69,"is_primary":false,"text":[{"text":"            pipex!(@async_with_error_handling input, $var, $fn_call)","highlight_start":13,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":5600,"byte_end":5640,"line_start":174,"line_end":174,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":10362,"byte_end":10490,"line_start":323,"line_end":326,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 3, 4, 5]","highlight_start":1,"highlight_end":32},{"text":"            => async? |x| process_with_fail_fast(x)  // Natural function call!","highlight_start":1,"highlight_end":79},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected struct `Vec<Result<_, _>>`\n   found struct `Vec<impl futures::Future<Output = Result<i32, std::string::String>>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"src/lib.rs","byte_start":1606,"byte_end":1613,"line_start":50,"line_end":50,"column_start":23,"column_end":30,"is_primary":false,"text":[{"text":"    fn handle_results(results: Vec<Result<T, E>>) -> Self::Output;","highlight_start":23,"highlight_end":30}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":1591,"byte_end":1605,"line_start":50,"line_end":50,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"    fn handle_results(results: Vec<Result<T, E>>) -> Self::Output;","highlight_start":8,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:213:63\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m213\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                    Ok($crate::IgnoreStrategy::handle_results(futures_results))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `Vec<Result<_, _>>`, found `Vec<impl Future<Output = ...>>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this function are incorrect\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m323\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        let result = pipex!(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m ______________________-\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m324\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            vec![1, 2, 3, 4, 5]\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m325\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            => async? |x| process_with_fail_fast(x)  // Natural function call!\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m326\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        );\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected struct `Vec<\u001b[0m\u001b[0m\u001b[1m\u001b[35mResult<_, _>\u001b[0m\u001b[0m>`\u001b[0m\n\u001b[0m               found struct `Vec<\u001b[0m\u001b[0m\u001b[1m\u001b[35mimpl futures::Future<Output = Result<i32, std::string::String>>\u001b[0m\u001b[0m>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:50:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m50\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn handle_results(results: Vec<Result<T, E>>) -> Self::Output;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `pipex` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":7501,"byte_end":7516,"line_start":219,"line_end":219,"column_start":64,"column_end":79,"is_primary":true,"text":[{"text":"                    Ok($crate::CollectStrategy::handle_results(futures_results))","highlight_start":64,"highlight_end":79}],"label":"expected `Vec<Result<_, _>>`, found `Vec<impl Future<Output = ...>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":6510,"byte_end":6566,"line_start":198,"line_end":198,"column_start":13,"column_end":69,"is_primary":false,"text":[{"text":"            pipex!(@async_with_error_handling input, $var, $fn_call)","highlight_start":13,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":5600,"byte_end":5640,"line_start":174,"line_end":174,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":10362,"byte_end":10490,"line_start":323,"line_end":326,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 3, 4, 5]","highlight_start":1,"highlight_end":32},{"text":"            => async? |x| process_with_fail_fast(x)  // Natural function call!","highlight_start":1,"highlight_end":79},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":7461,"byte_end":7500,"line_start":219,"line_end":219,"column_start":24,"column_end":63,"is_primary":false,"text":[{"text":"                    Ok($crate::CollectStrategy::handle_results(futures_results))","highlight_start":24,"highlight_end":63}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":6510,"byte_end":6566,"line_start":198,"line_end":198,"column_start":13,"column_end":69,"is_primary":false,"text":[{"text":"            pipex!(@async_with_error_handling input, $var, $fn_call)","highlight_start":13,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":5600,"byte_end":5640,"line_start":174,"line_end":174,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":10362,"byte_end":10490,"line_start":323,"line_end":326,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 3, 4, 5]","highlight_start":1,"highlight_end":32},{"text":"            => async? |x| process_with_fail_fast(x)  // Natural function call!","highlight_start":1,"highlight_end":79},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected struct `Vec<Result<_, _>>`\n   found struct `Vec<impl futures::Future<Output = Result<i32, std::string::String>>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"src/lib.rs","byte_start":1606,"byte_end":1613,"line_start":50,"line_end":50,"column_start":23,"column_end":30,"is_primary":false,"text":[{"text":"    fn handle_results(results: Vec<Result<T, E>>) -> Self::Output;","highlight_start":23,"highlight_end":30}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":1591,"byte_end":1605,"line_start":50,"line_end":50,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"    fn handle_results(results: Vec<Result<T, E>>) -> Self::Output;","highlight_start":8,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:219:64\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m219\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                    Ok($crate::CollectStrategy::handle_results(futures_results))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `Vec<Result<_, _>>`, found `Vec<impl Future<Output = ...>>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this function are incorrect\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m323\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        let result = pipex!(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m ______________________-\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m324\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            vec![1, 2, 3, 4, 5]\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m325\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            => async? |x| process_with_fail_fast(x)  // Natural function call!\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m326\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        );\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected struct `Vec<\u001b[0m\u001b[0m\u001b[1m\u001b[35mResult<_, _>\u001b[0m\u001b[0m>`\u001b[0m\n\u001b[0m               found struct `Vec<\u001b[0m\u001b[0m\u001b[1m\u001b[35mimpl futures::Future<Output = Result<i32, std::string::String>>\u001b[0m\u001b[0m>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:50:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m50\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn handle_results(results: Vec<Result<T, E>>) -> Self::Output;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `pipex` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"`match` arms have incompatible types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":8011,"byte_end":8022,"line_start":231,"line_end":231,"column_start":21,"column_end":32,"is_primary":true,"text":[{"text":"                    Ok(results)","highlight_start":21,"highlight_end":32}],"label":"expected `Result<Vec<Result<_, _>>, _>`, found `Result<Vec<i32>, _>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":6510,"byte_end":6566,"line_start":198,"line_end":198,"column_start":13,"column_end":69,"is_primary":false,"text":[{"text":"            pipex!(@async_with_error_handling input, $var, $fn_call)","highlight_start":13,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":5600,"byte_end":5640,"line_start":174,"line_end":174,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":10362,"byte_end":10490,"line_start":323,"line_end":326,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 3, 4, 5]","highlight_start":1,"highlight_end":32},{"text":"            => async? |x| process_with_fail_fast(x)  // Natural function call!","highlight_start":1,"highlight_end":79},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":7143,"byte_end":7202,"line_start":213,"line_end":213,"column_start":21,"column_end":80,"is_primary":false,"text":[{"text":"                    Ok($crate::IgnoreStrategy::handle_results(futures_results))","highlight_start":21,"highlight_end":80}],"label":"this is found to be of type `Result<Vec<Result<_, _>>, _>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":6510,"byte_end":6566,"line_start":198,"line_end":198,"column_start":13,"column_end":69,"is_primary":false,"text":[{"text":"            pipex!(@async_with_error_handling input, $var, $fn_call)","highlight_start":13,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":5600,"byte_end":5640,"line_start":174,"line_end":174,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":10362,"byte_end":10490,"line_start":323,"line_end":326,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 3, 4, 5]","highlight_start":1,"highlight_end":32},{"text":"            => async? |x| process_with_fail_fast(x)  // Natural function call!","highlight_start":1,"highlight_end":79},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":7458,"byte_end":7518,"line_start":219,"line_end":219,"column_start":21,"column_end":81,"is_primary":false,"text":[{"text":"                    Ok($crate::CollectStrategy::handle_results(futures_results))","highlight_start":21,"highlight_end":81}],"label":"this is found to be of type `Result<Vec<Result<_, _>>, _>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":6510,"byte_end":6566,"line_start":198,"line_end":198,"column_start":13,"column_end":69,"is_primary":false,"text":[{"text":"            pipex!(@async_with_error_handling input, $var, $fn_call)","highlight_start":13,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":5600,"byte_end":5640,"line_start":174,"line_end":174,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":10362,"byte_end":10490,"line_start":323,"line_end":326,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 3, 4, 5]","highlight_start":1,"highlight_end":32},{"text":"            => async? |x| process_with_fail_fast(x)  // Natural function call!","highlight_start":1,"highlight_end":79},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":6891,"byte_end":8054,"line_start":208,"line_end":233,"column_start":13,"column_end":14,"is_primary":false,"text":[{"text":"            match strategy {","highlight_start":13,"highlight_end":29},{"text":"                \"ignore\" => {","highlight_start":1,"highlight_end":30},{"text":"                    let futures_results = $crate::futures::future::join_all(","highlight_start":1,"highlight_end":77},{"text":"                        $input.into_iter().map(|$var| async move { $fn_call })","highlight_start":1,"highlight_end":79},{"text":"                    ).await;","highlight_start":1,"highlight_end":29},{"text":"                    Ok($crate::IgnoreStrategy::handle_results(futures_results))","highlight_start":1,"highlight_end":80},{"text":"                },","highlight_start":1,"highlight_end":19},{"text":"                \"collect\" => {","highlight_start":1,"highlight_end":31},{"text":"                    let futures_results = $crate::futures::future::join_all(","highlight_start":1,"highlight_end":77},{"text":"                        $input.into_iter().map(|$var| async move { $fn_call })","highlight_start":1,"highlight_end":79},{"text":"                    ).await;","highlight_start":1,"highlight_end":29},{"text":"                    Ok($crate::CollectStrategy::handle_results(futures_results))","highlight_start":1,"highlight_end":81},{"text":"                },","highlight_start":1,"highlight_end":19},{"text":"                _ => {","highlight_start":1,"highlight_end":23},{"text":"                    // Default: fail_fast - process sequentially to truly fail fast","highlight_start":1,"highlight_end":84},{"text":"                    let mut results = Vec::new();","highlight_start":1,"highlight_end":50},{"text":"                    for item in $input {","highlight_start":1,"highlight_end":41},{"text":"                        let $var = item;","highlight_start":1,"highlight_end":41},{"text":"                        match { $fn_call }.await {","highlight_start":1,"highlight_end":51},{"text":"                            Ok(value) => results.push(value),","highlight_start":1,"highlight_end":62},{"text":"                            Err(e) => return Err(e),","highlight_start":1,"highlight_end":53},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    Ok(results)","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14}],"label":"`match` arms have incompatible types","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":6510,"byte_end":6566,"line_start":198,"line_end":198,"column_start":13,"column_end":69,"is_primary":false,"text":[{"text":"            pipex!(@async_with_error_handling input, $var, $fn_call)","highlight_start":13,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":5600,"byte_end":5640,"line_start":174,"line_end":174,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":10362,"byte_end":10490,"line_start":323,"line_end":326,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 3, 4, 5]","highlight_start":1,"highlight_end":32},{"text":"            => async? |x| process_with_fail_fast(x)  // Natural function call!","highlight_start":1,"highlight_end":79},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected enum `Result<Vec<Result<_, _>>, _>`\n   found enum `Result<Vec<i32>, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"try wrapping the expression in `Err`","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":8011,"byte_end":8011,"line_start":231,"line_end":231,"column_start":21,"column_end":21,"is_primary":true,"text":[{"text":"                    Ok(results)","highlight_start":21,"highlight_end":21}],"label":null,"suggested_replacement":"Err(","suggestion_applicability":"MaybeIncorrect","expansion":{"span":{"file_name":"src/lib.rs","byte_start":6510,"byte_end":6566,"line_start":198,"line_end":198,"column_start":13,"column_end":69,"is_primary":false,"text":[{"text":"            pipex!(@async_with_error_handling input, $var, $fn_call)","highlight_start":13,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":5600,"byte_end":5640,"line_start":174,"line_end":174,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":10362,"byte_end":10490,"line_start":323,"line_end":326,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 3, 4, 5]","highlight_start":1,"highlight_end":32},{"text":"            => async? |x| process_with_fail_fast(x)  // Natural function call!","highlight_start":1,"highlight_end":79},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":8022,"byte_end":8022,"line_start":231,"line_end":231,"column_start":32,"column_end":32,"is_primary":true,"text":[{"text":"                    Ok(results)","highlight_start":32,"highlight_end":32}],"label":null,"suggested_replacement":")","suggestion_applicability":"MaybeIncorrect","expansion":{"span":{"file_name":"src/lib.rs","byte_start":6510,"byte_end":6566,"line_start":198,"line_end":198,"column_start":13,"column_end":69,"is_primary":false,"text":[{"text":"            pipex!(@async_with_error_handling input, $var, $fn_call)","highlight_start":13,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":5600,"byte_end":5640,"line_start":174,"line_end":174,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":10362,"byte_end":10490,"line_start":323,"line_end":326,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 3, 4, 5]","highlight_start":1,"highlight_end":32},{"text":"            => async? |x| process_with_fail_fast(x)  // Natural function call!","highlight_start":1,"highlight_end":79},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: `match` arms have incompatible types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:231:21\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m208\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m            match strategy {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m209\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                \"ignore\" => {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m210\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    let futures_results = $crate::futures::future::join_all(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m211\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        $input.into_iter().map(|$var| async move { $fn_call })\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m212\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    ).await;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m213\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    Ok($crate::IgnoreStrategy::handle_results(futures_results))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis is found to be of type `Result<Vec<Result<_, _>>, _>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m219\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    Ok($crate::CollectStrategy::handle_results(futures_results))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis is found to be of type `Result<Vec<Result<_, _>>, _>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m231\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    Ok(results)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `Result<Vec<Result<_, _>>, _>`, found `Result<Vec<i32>, _>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m232\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m233\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_____________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m`match` arms have incompatible types\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m323\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        let result = pipex!(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m ______________________-\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m324\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            vec![1, 2, 3, 4, 5]\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m325\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            => async? |x| process_with_fail_fast(x)  // Natural function call!\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m326\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        );\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected enum `Result<Vec<\u001b[0m\u001b[0m\u001b[1m\u001b[35mResult<_, _>\u001b[0m\u001b[0m>, \u001b[0m\u001b[0m\u001b[1m\u001b[35m_\u001b[0m\u001b[0m>`\u001b[0m\n\u001b[0m               found enum `Result<Vec<\u001b[0m\u001b[0m\u001b[1m\u001b[35mi32\u001b[0m\u001b[0m>, \u001b[0m\u001b[0m\u001b[1m\u001b[35m_\u001b[0m\u001b[0m>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `pipex` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: try wrapping the expression in `Err`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m231\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[38;5;10mErr(\u001b[0m\u001b[0mOk(results)\u001b[0m\u001b[0m\u001b[38;5;10m)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[38;5;10m++++\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `is_err` found for struct `Vec<_>` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":10569,"byte_end":10575,"line_start":329,"line_end":329,"column_start":24,"column_end":30,"is_primary":true,"text":[{"text":"        assert!(result.is_err());","highlight_start":24,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is a method `iter` with a similar name","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":10569,"byte_end":10575,"line_start":329,"line_end":329,"column_start":24,"column_end":30,"is_primary":true,"text":[{"text":"        assert!(result.is_err());","highlight_start":24,"highlight_end":30}],"label":null,"suggested_replacement":"iter","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `is_err` found for struct `Vec<_>` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:329:24\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m329\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        assert!(result.is_err());\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: there is a method `iter` with a similar name\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m329\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m        assert!(result.\u001b[0m\u001b[0m\u001b[38;5;9mis_err\u001b[0m\u001b[0m());\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m329\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m        assert!(result.\u001b[0m\u001b[0m\u001b[38;5;10miter\u001b[0m\u001b[0m());\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":7185,"byte_end":7200,"line_start":213,"line_end":213,"column_start":63,"column_end":78,"is_primary":true,"text":[{"text":"                    Ok($crate::IgnoreStrategy::handle_results(futures_results))","highlight_start":63,"highlight_end":78}],"label":"expected `Vec<Result<_, _>>`, found `Vec<impl Future<Output = ...>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":6510,"byte_end":6566,"line_start":198,"line_end":198,"column_start":13,"column_end":69,"is_primary":false,"text":[{"text":"            pipex!(@async_with_error_handling input, $var, $fn_call)","highlight_start":13,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":5600,"byte_end":5640,"line_start":174,"line_end":174,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":10670,"byte_end":10863,"line_start":334,"line_end":338,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 4, 5]  // Skip 3 to avoid error","highlight_start":1,"highlight_end":55},{"text":"            => async? |x| process_with_ignore(x)","highlight_start":1,"highlight_end":49},{"text":"            => |x| x + 1  // This should work on the successful results","highlight_start":1,"highlight_end":72},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":7146,"byte_end":7184,"line_start":213,"line_end":213,"column_start":24,"column_end":62,"is_primary":false,"text":[{"text":"                    Ok($crate::IgnoreStrategy::handle_results(futures_results))","highlight_start":24,"highlight_end":62}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":6510,"byte_end":6566,"line_start":198,"line_end":198,"column_start":13,"column_end":69,"is_primary":false,"text":[{"text":"            pipex!(@async_with_error_handling input, $var, $fn_call)","highlight_start":13,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":5600,"byte_end":5640,"line_start":174,"line_end":174,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":10670,"byte_end":10863,"line_start":334,"line_end":338,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 4, 5]  // Skip 3 to avoid error","highlight_start":1,"highlight_end":55},{"text":"            => async? |x| process_with_ignore(x)","highlight_start":1,"highlight_end":49},{"text":"            => |x| x + 1  // This should work on the successful results","highlight_start":1,"highlight_end":72},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected struct `Vec<Result<_, _>>`\n   found struct `Vec<impl futures::Future<Output = Result<i32, std::string::String>>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"src/lib.rs","byte_start":1606,"byte_end":1613,"line_start":50,"line_end":50,"column_start":23,"column_end":30,"is_primary":false,"text":[{"text":"    fn handle_results(results: Vec<Result<T, E>>) -> Self::Output;","highlight_start":23,"highlight_end":30}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":1591,"byte_end":1605,"line_start":50,"line_end":50,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"    fn handle_results(results: Vec<Result<T, E>>) -> Self::Output;","highlight_start":8,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:213:63\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m213\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                    Ok($crate::IgnoreStrategy::handle_results(futures_results))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `Vec<Result<_, _>>`, found `Vec<impl Future<Output = ...>>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this function are incorrect\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m334\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        let result = pipex!(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m ______________________-\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m335\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            vec![1, 2, 4, 5]  // Skip 3 to avoid error\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m336\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            => async? |x| process_with_ignore(x)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m337\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            => |x| x + 1  // This should work on the successful results\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m338\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        );\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected struct `Vec<\u001b[0m\u001b[0m\u001b[1m\u001b[35mResult<_, _>\u001b[0m\u001b[0m>`\u001b[0m\n\u001b[0m               found struct `Vec<\u001b[0m\u001b[0m\u001b[1m\u001b[35mimpl futures::Future<Output = Result<i32, std::string::String>>\u001b[0m\u001b[0m>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:50:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m50\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn handle_results(results: Vec<Result<T, E>>) -> Self::Output;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `pipex` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":7501,"byte_end":7516,"line_start":219,"line_end":219,"column_start":64,"column_end":79,"is_primary":true,"text":[{"text":"                    Ok($crate::CollectStrategy::handle_results(futures_results))","highlight_start":64,"highlight_end":79}],"label":"expected `Vec<Result<_, _>>`, found `Vec<impl Future<Output = ...>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":6510,"byte_end":6566,"line_start":198,"line_end":198,"column_start":13,"column_end":69,"is_primary":false,"text":[{"text":"            pipex!(@async_with_error_handling input, $var, $fn_call)","highlight_start":13,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":5600,"byte_end":5640,"line_start":174,"line_end":174,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":10670,"byte_end":10863,"line_start":334,"line_end":338,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 4, 5]  // Skip 3 to avoid error","highlight_start":1,"highlight_end":55},{"text":"            => async? |x| process_with_ignore(x)","highlight_start":1,"highlight_end":49},{"text":"            => |x| x + 1  // This should work on the successful results","highlight_start":1,"highlight_end":72},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":7461,"byte_end":7500,"line_start":219,"line_end":219,"column_start":24,"column_end":63,"is_primary":false,"text":[{"text":"                    Ok($crate::CollectStrategy::handle_results(futures_results))","highlight_start":24,"highlight_end":63}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":6510,"byte_end":6566,"line_start":198,"line_end":198,"column_start":13,"column_end":69,"is_primary":false,"text":[{"text":"            pipex!(@async_with_error_handling input, $var, $fn_call)","highlight_start":13,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":5600,"byte_end":5640,"line_start":174,"line_end":174,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":10670,"byte_end":10863,"line_start":334,"line_end":338,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 4, 5]  // Skip 3 to avoid error","highlight_start":1,"highlight_end":55},{"text":"            => async? |x| process_with_ignore(x)","highlight_start":1,"highlight_end":49},{"text":"            => |x| x + 1  // This should work on the successful results","highlight_start":1,"highlight_end":72},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected struct `Vec<Result<_, _>>`\n   found struct `Vec<impl futures::Future<Output = Result<i32, std::string::String>>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"src/lib.rs","byte_start":1606,"byte_end":1613,"line_start":50,"line_end":50,"column_start":23,"column_end":30,"is_primary":false,"text":[{"text":"    fn handle_results(results: Vec<Result<T, E>>) -> Self::Output;","highlight_start":23,"highlight_end":30}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":1591,"byte_end":1605,"line_start":50,"line_end":50,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"    fn handle_results(results: Vec<Result<T, E>>) -> Self::Output;","highlight_start":8,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:219:64\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m219\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                    Ok($crate::CollectStrategy::handle_results(futures_results))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `Vec<Result<_, _>>`, found `Vec<impl Future<Output = ...>>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this function are incorrect\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m334\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        let result = pipex!(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m ______________________-\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m335\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            vec![1, 2, 4, 5]  // Skip 3 to avoid error\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m336\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            => async? |x| process_with_ignore(x)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m337\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            => |x| x + 1  // This should work on the successful results\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m338\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        );\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected struct `Vec<\u001b[0m\u001b[0m\u001b[1m\u001b[35mResult<_, _>\u001b[0m\u001b[0m>`\u001b[0m\n\u001b[0m               found struct `Vec<\u001b[0m\u001b[0m\u001b[1m\u001b[35mimpl futures::Future<Output = Result<i32, std::string::String>>\u001b[0m\u001b[0m>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:50:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m50\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn handle_results(results: Vec<Result<T, E>>) -> Self::Output;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `pipex` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"`match` arms have incompatible types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":8011,"byte_end":8022,"line_start":231,"line_end":231,"column_start":21,"column_end":32,"is_primary":true,"text":[{"text":"                    Ok(results)","highlight_start":21,"highlight_end":32}],"label":"expected `Result<Vec<Result<_, _>>, _>`, found `Result<Vec<i32>, _>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":6510,"byte_end":6566,"line_start":198,"line_end":198,"column_start":13,"column_end":69,"is_primary":false,"text":[{"text":"            pipex!(@async_with_error_handling input, $var, $fn_call)","highlight_start":13,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":5600,"byte_end":5640,"line_start":174,"line_end":174,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":10670,"byte_end":10863,"line_start":334,"line_end":338,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 4, 5]  // Skip 3 to avoid error","highlight_start":1,"highlight_end":55},{"text":"            => async? |x| process_with_ignore(x)","highlight_start":1,"highlight_end":49},{"text":"            => |x| x + 1  // This should work on the successful results","highlight_start":1,"highlight_end":72},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":7143,"byte_end":7202,"line_start":213,"line_end":213,"column_start":21,"column_end":80,"is_primary":false,"text":[{"text":"                    Ok($crate::IgnoreStrategy::handle_results(futures_results))","highlight_start":21,"highlight_end":80}],"label":"this is found to be of type `Result<Vec<Result<_, _>>, _>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":6510,"byte_end":6566,"line_start":198,"line_end":198,"column_start":13,"column_end":69,"is_primary":false,"text":[{"text":"            pipex!(@async_with_error_handling input, $var, $fn_call)","highlight_start":13,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":5600,"byte_end":5640,"line_start":174,"line_end":174,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":10670,"byte_end":10863,"line_start":334,"line_end":338,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 4, 5]  // Skip 3 to avoid error","highlight_start":1,"highlight_end":55},{"text":"            => async? |x| process_with_ignore(x)","highlight_start":1,"highlight_end":49},{"text":"            => |x| x + 1  // This should work on the successful results","highlight_start":1,"highlight_end":72},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":7458,"byte_end":7518,"line_start":219,"line_end":219,"column_start":21,"column_end":81,"is_primary":false,"text":[{"text":"                    Ok($crate::CollectStrategy::handle_results(futures_results))","highlight_start":21,"highlight_end":81}],"label":"this is found to be of type `Result<Vec<Result<_, _>>, _>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":6510,"byte_end":6566,"line_start":198,"line_end":198,"column_start":13,"column_end":69,"is_primary":false,"text":[{"text":"            pipex!(@async_with_error_handling input, $var, $fn_call)","highlight_start":13,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":5600,"byte_end":5640,"line_start":174,"line_end":174,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":10670,"byte_end":10863,"line_start":334,"line_end":338,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 4, 5]  // Skip 3 to avoid error","highlight_start":1,"highlight_end":55},{"text":"            => async? |x| process_with_ignore(x)","highlight_start":1,"highlight_end":49},{"text":"            => |x| x + 1  // This should work on the successful results","highlight_start":1,"highlight_end":72},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":6891,"byte_end":8054,"line_start":208,"line_end":233,"column_start":13,"column_end":14,"is_primary":false,"text":[{"text":"            match strategy {","highlight_start":13,"highlight_end":29},{"text":"                \"ignore\" => {","highlight_start":1,"highlight_end":30},{"text":"                    let futures_results = $crate::futures::future::join_all(","highlight_start":1,"highlight_end":77},{"text":"                        $input.into_iter().map(|$var| async move { $fn_call })","highlight_start":1,"highlight_end":79},{"text":"                    ).await;","highlight_start":1,"highlight_end":29},{"text":"                    Ok($crate::IgnoreStrategy::handle_results(futures_results))","highlight_start":1,"highlight_end":80},{"text":"                },","highlight_start":1,"highlight_end":19},{"text":"                \"collect\" => {","highlight_start":1,"highlight_end":31},{"text":"                    let futures_results = $crate::futures::future::join_all(","highlight_start":1,"highlight_end":77},{"text":"                        $input.into_iter().map(|$var| async move { $fn_call })","highlight_start":1,"highlight_end":79},{"text":"                    ).await;","highlight_start":1,"highlight_end":29},{"text":"                    Ok($crate::CollectStrategy::handle_results(futures_results))","highlight_start":1,"highlight_end":81},{"text":"                },","highlight_start":1,"highlight_end":19},{"text":"                _ => {","highlight_start":1,"highlight_end":23},{"text":"                    // Default: fail_fast - process sequentially to truly fail fast","highlight_start":1,"highlight_end":84},{"text":"                    let mut results = Vec::new();","highlight_start":1,"highlight_end":50},{"text":"                    for item in $input {","highlight_start":1,"highlight_end":41},{"text":"                        let $var = item;","highlight_start":1,"highlight_end":41},{"text":"                        match { $fn_call }.await {","highlight_start":1,"highlight_end":51},{"text":"                            Ok(value) => results.push(value),","highlight_start":1,"highlight_end":62},{"text":"                            Err(e) => return Err(e),","highlight_start":1,"highlight_end":53},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    Ok(results)","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14}],"label":"`match` arms have incompatible types","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":6510,"byte_end":6566,"line_start":198,"line_end":198,"column_start":13,"column_end":69,"is_primary":false,"text":[{"text":"            pipex!(@async_with_error_handling input, $var, $fn_call)","highlight_start":13,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":5600,"byte_end":5640,"line_start":174,"line_end":174,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":10670,"byte_end":10863,"line_start":334,"line_end":338,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 4, 5]  // Skip 3 to avoid error","highlight_start":1,"highlight_end":55},{"text":"            => async? |x| process_with_ignore(x)","highlight_start":1,"highlight_end":49},{"text":"            => |x| x + 1  // This should work on the successful results","highlight_start":1,"highlight_end":72},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected enum `Result<Vec<Result<_, _>>, _>`\n   found enum `Result<Vec<i32>, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"try wrapping the expression in `Err`","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":8011,"byte_end":8011,"line_start":231,"line_end":231,"column_start":21,"column_end":21,"is_primary":true,"text":[{"text":"                    Ok(results)","highlight_start":21,"highlight_end":21}],"label":null,"suggested_replacement":"Err(","suggestion_applicability":"MaybeIncorrect","expansion":{"span":{"file_name":"src/lib.rs","byte_start":6510,"byte_end":6566,"line_start":198,"line_end":198,"column_start":13,"column_end":69,"is_primary":false,"text":[{"text":"            pipex!(@async_with_error_handling input, $var, $fn_call)","highlight_start":13,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":5600,"byte_end":5640,"line_start":174,"line_end":174,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":10670,"byte_end":10863,"line_start":334,"line_end":338,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 4, 5]  // Skip 3 to avoid error","highlight_start":1,"highlight_end":55},{"text":"            => async? |x| process_with_ignore(x)","highlight_start":1,"highlight_end":49},{"text":"            => |x| x + 1  // This should work on the successful results","highlight_start":1,"highlight_end":72},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":8022,"byte_end":8022,"line_start":231,"line_end":231,"column_start":32,"column_end":32,"is_primary":true,"text":[{"text":"                    Ok(results)","highlight_start":32,"highlight_end":32}],"label":null,"suggested_replacement":")","suggestion_applicability":"MaybeIncorrect","expansion":{"span":{"file_name":"src/lib.rs","byte_start":6510,"byte_end":6566,"line_start":198,"line_end":198,"column_start":13,"column_end":69,"is_primary":false,"text":[{"text":"            pipex!(@async_with_error_handling input, $var, $fn_call)","highlight_start":13,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":5600,"byte_end":5640,"line_start":174,"line_end":174,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":10670,"byte_end":10863,"line_start":334,"line_end":338,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 4, 5]  // Skip 3 to avoid error","highlight_start":1,"highlight_end":55},{"text":"            => async? |x| process_with_ignore(x)","highlight_start":1,"highlight_end":49},{"text":"            => |x| x + 1  // This should work on the successful results","highlight_start":1,"highlight_end":72},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":5508,"byte_end":5526,"line_start":171,"line_end":171,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: `match` arms have incompatible types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:231:21\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m208\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m            match strategy {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m209\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                \"ignore\" => {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m210\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    let futures_results = $crate::futures::future::join_all(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m211\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        $input.into_iter().map(|$var| async move { $fn_call })\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m212\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    ).await;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m213\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    Ok($crate::IgnoreStrategy::handle_results(futures_results))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis is found to be of type `Result<Vec<Result<_, _>>, _>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m219\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    Ok($crate::CollectStrategy::handle_results(futures_results))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis is found to be of type `Result<Vec<Result<_, _>>, _>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m231\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    Ok(results)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `Result<Vec<Result<_, _>>, _>`, found `Result<Vec<i32>, _>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m232\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m233\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_____________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m`match` arms have incompatible types\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m334\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        let result = pipex!(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m ______________________-\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m335\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            vec![1, 2, 4, 5]  // Skip 3 to avoid error\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m336\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            => async? |x| process_with_ignore(x)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m337\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            => |x| x + 1  // This should work on the successful results\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m338\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        );\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected enum `Result<Vec<\u001b[0m\u001b[0m\u001b[1m\u001b[35mResult<_, _>\u001b[0m\u001b[0m>, \u001b[0m\u001b[0m\u001b[1m\u001b[35m_\u001b[0m\u001b[0m>`\u001b[0m\n\u001b[0m               found enum `Result<Vec<\u001b[0m\u001b[0m\u001b[1m\u001b[35mi32\u001b[0m\u001b[0m>, \u001b[0m\u001b[0m\u001b[1m\u001b[35m_\u001b[0m\u001b[0m>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `pipex` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: try wrapping the expression in `Err`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m231\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[38;5;10mErr(\u001b[0m\u001b[0mOk(results)\u001b[0m\u001b[0m\u001b[38;5;10m)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[38;5;10m++++\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"can't compare `Vec<_>` with `Result<Vec<{integer}>, _>`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/dransy/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1485,"byte_end":1487,"line_start":46,"line_end":46,"column_start":32,"column_end":34,"is_primary":true,"text":[{"text":"                if !(*left_val == *right_val) {","highlight_start":32,"highlight_end":34}],"label":"no implementation for `Vec<_> == Result<Vec<{integer}>, _>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":10874,"byte_end":10915,"line_start":340,"line_end":340,"column_start":9,"column_end":50,"is_primary":false,"text":[{"text":"        assert_eq!(result, Ok(vec![3, 5, 9, 11]));","highlight_start":9,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"assert_eq!","def_site_span":{"file_name":"/Users/dransy/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1315,"byte_end":1337,"line_start":42,"line_end":42,"column_start":1,"column_end":23,"is_primary":false,"text":[{"text":"macro_rules! assert_eq {","highlight_start":1,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `PartialEq<Result<Vec<{integer}>, _>>` is not implemented for `Vec<_>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `PartialEq<Rhs>`:\n  `Vec<T, A1>` implements `PartialEq<Vec<U, A2>>`\n  `Vec<T, A>` implements `PartialEq<&[U; N]>`\n  `Vec<T, A>` implements `PartialEq<&[U]>`\n  `Vec<T, A>` implements `PartialEq<&mut [U]>`\n  `Vec<T, A>` implements `PartialEq<[U; N]>`\n  `Vec<T, A>` implements `PartialEq<[U]>`\n  `Vec<u8>` implements `PartialEq<ByteString>`\n  `Vec<u8>` implements `PartialEq<bytes::bytes::Bytes>`\nand 2 others","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: can't compare `Vec<_>` with `Result<Vec<{integer}>, _>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:340:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m340\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        assert_eq!(result, Ok(vec![3, 5, 9, 11]));\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mno implementation for `Vec<_> == Result<Vec<{integer}>, _>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `PartialEq<Result<Vec<{integer}>, _>>` is not implemented for `Vec<_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `PartialEq<Rhs>`:\u001b[0m\n\u001b[0m              `Vec<T, A1>` implements `PartialEq<Vec<U, A2>>`\u001b[0m\n\u001b[0m              `Vec<T, A>` implements `PartialEq<&[U; N]>`\u001b[0m\n\u001b[0m              `Vec<T, A>` implements `PartialEq<&[U]>`\u001b[0m\n\u001b[0m              `Vec<T, A>` implements `PartialEq<&mut [U]>`\u001b[0m\n\u001b[0m              `Vec<T, A>` implements `PartialEq<[U; N]>`\u001b[0m\n\u001b[0m              `Vec<T, A>` implements `PartialEq<[U]>`\u001b[0m\n\u001b[0m              `Vec<u8>` implements `PartialEq<ByteString>`\u001b[0m\n\u001b[0m              `Vec<u8>` implements `PartialEq<bytes::bytes::Bytes>`\u001b[0m\n\u001b[0m            and 2 others\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 19 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 19 previous errors\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0277, E0308, E0599, E0659.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mSome errors have detailed explanations: E0277, E0308, E0599, E0659.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0277`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about an error, try `rustc --explain E0277`.\u001b[0m\n"}
