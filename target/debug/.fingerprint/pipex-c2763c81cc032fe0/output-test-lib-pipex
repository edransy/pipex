{"$message_type":"diagnostic","message":"can't use a procedural macro from the same crate that defines it","code":null,"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":15576,"byte_end":15583,"line_start":459,"line_end":459,"column_start":7,"column_end":14,"is_primary":true,"text":[{"text":"    #[collect(retry = 2)]","highlight_start":7,"highlight_end":14}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you can define integration tests in a directory named `tests`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: can't use a procedural macro from the same crate that defines it\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:459:7\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m459\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    #[collect(retry = 2)]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: you can define integration tests in a directory named `tests`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"can't use a procedural macro from the same crate that defines it","code":null,"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":16169,"byte_end":16178,"line_start":477,"line_end":477,"column_start":7,"column_end":16,"is_primary":true,"text":[{"text":"    #[fail_fast(retry = 5)]","highlight_start":7,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you can define integration tests in a directory named `tests`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: can't use a procedural macro from the same crate that defines it\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:477:7\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m477\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    #[fail_fast(retry = 5)]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: you can define integration tests in a directory named `tests`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unresolved imports `syn::AttributeArgs`, `syn::NestedMeta`","code":{"code":"E0432","explanation":"An import was unresolved.\n\nErroneous code example:\n\n```compile_fail,E0432\nuse something::Foo; // error: unresolved import `something::Foo`.\n```\n\nIn Rust 2015, paths in `use` statements are relative to the crate root. To\nimport items relative to the current and parent modules, use the `self::` and\n`super::` prefixes, respectively.\n\nIn Rust 2018 or later, paths in `use` statements are relative to the current\nmodule unless they begin with the name of a crate or a literal `crate::`, in\nwhich case they start from the crate root. As in Rust 2015 code, the `self::`\nand `super::` prefixes refer to the current and parent modules respectively.\n\nAlso verify that you didn't misspell the import name and that the import exists\nin the module from where you tried to import it. Example:\n\n```\nuse self::something::Foo; // Ok.\n\nmod something {\n    pub struct Foo;\n}\n# fn main() {}\n```\n\nIf you tried to use a module from an external crate and are using Rust 2015,\nyou may have missed the `extern crate` declaration (which is usually placed in\nthe crate root):\n\n```edition2015\nextern crate core; // Required to use the `core` crate in Rust 2015.\n\nuse core::any;\n# fn main() {}\n```\n\nSince Rust 2018 the `extern crate` declaration is not required and\nyou can instead just `use` it:\n\n```edition2018\nuse core::any; // No extern crate required in Rust 2018.\n# fn main() {}\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":1579,"byte_end":1592,"line_start":51,"line_end":51,"column_start":38,"column_end":51,"is_primary":true,"text":[{"text":"use syn::{parse_macro_input, ItemFn, AttributeArgs, NestedMeta, Meta, Lit};","highlight_start":38,"highlight_end":51}],"label":"no `AttributeArgs` in the root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":1594,"byte_end":1604,"line_start":51,"line_end":51,"column_start":53,"column_end":63,"is_primary":true,"text":[{"text":"use syn::{parse_macro_input, ItemFn, AttributeArgs, NestedMeta, Meta, Lit};","highlight_start":53,"highlight_end":63}],"label":"no `NestedMeta` in the root","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a similar name exists in the module","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":1579,"byte_end":1592,"line_start":51,"line_end":51,"column_start":38,"column_end":51,"is_primary":true,"text":[{"text":"use syn::{parse_macro_input, ItemFn, AttributeArgs, NestedMeta, Meta, Lit};","highlight_start":38,"highlight_end":51}],"label":null,"suggested_replacement":"Attribute","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0432]\u001b[0m\u001b[0m\u001b[1m: unresolved imports `syn::AttributeArgs`, `syn::NestedMeta`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:51:38\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m51\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse syn::{parse_macro_input, ItemFn, AttributeArgs, NestedMeta, Meta, Lit};\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mno `NestedMeta` in the root\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mno `AttributeArgs` in the root\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: a similar name exists in the module: `Attribute`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of unresolved module or unlinked crate `proc_macro2`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":5425,"byte_end":5436,"line_start":177,"line_end":177,"column_start":9,"column_end":20,"is_primary":true,"text":[{"text":"        proc_macro2::Span::call_site()","highlight_start":9,"highlight_end":20}],"label":"use of unresolved module or unlinked crate `proc_macro2`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is a crate or module with a similar name","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":5425,"byte_end":5436,"line_start":177,"line_end":177,"column_start":9,"column_end":20,"is_primary":true,"text":[{"text":"        proc_macro2::Span::call_site()","highlight_start":9,"highlight_end":20}],"label":null,"suggested_replacement":"proc_macro","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":1275,"byte_end":1275,"line_start":38,"line_end":38,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::collections::HashMap;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use proc_macro::Span;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"if you import `Span`, refer to it directly","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":5425,"byte_end":5438,"line_start":177,"line_end":177,"column_start":9,"column_end":22,"is_primary":true,"text":[{"text":"        proc_macro2::Span::call_site()","highlight_start":9,"highlight_end":22}],"label":null,"suggested_replacement":"","suggestion_applicability":"Unspecified","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: use of unresolved module or unlinked crate `proc_macro2`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:177:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m177\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        proc_macro2::Span::call_site()\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of unresolved module or unlinked crate `proc_macro2`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: there is a crate or module with a similar name\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m177\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[38;5;9mproc_macro2\u001b[0m\u001b[0m::Span::call_site()\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m177\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[38;5;10mproc_macro\u001b[0m\u001b[0m::Span::call_site()\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider importing this struct\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m38\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+ use proc_macro::Span;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: if you import `Span`, refer to it directly\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m177\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[38;5;9mproc_macro2::\u001b[0m\u001b[0mSpan::call_site()\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m177\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m        Span::call_site()\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of unresolved module or unlinked crate `proc_macro2`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":7009,"byte_end":7020,"line_start":224,"line_end":224,"column_start":9,"column_end":20,"is_primary":true,"text":[{"text":"        proc_macro2::Span::call_site()","highlight_start":9,"highlight_end":20}],"label":"use of unresolved module or unlinked crate `proc_macro2`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is a crate or module with a similar name","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":7009,"byte_end":7020,"line_start":224,"line_end":224,"column_start":9,"column_end":20,"is_primary":true,"text":[{"text":"        proc_macro2::Span::call_site()","highlight_start":9,"highlight_end":20}],"label":null,"suggested_replacement":"proc_macro","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":1275,"byte_end":1275,"line_start":38,"line_end":38,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::collections::HashMap;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use proc_macro::Span;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"if you import `Span`, refer to it directly","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":7009,"byte_end":7022,"line_start":224,"line_end":224,"column_start":9,"column_end":22,"is_primary":true,"text":[{"text":"        proc_macro2::Span::call_site()","highlight_start":9,"highlight_end":22}],"label":null,"suggested_replacement":"","suggestion_applicability":"Unspecified","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: use of unresolved module or unlinked crate `proc_macro2`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:224:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m224\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        proc_macro2::Span::call_site()\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of unresolved module or unlinked crate `proc_macro2`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: there is a crate or module with a similar name\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m224\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[38;5;9mproc_macro2\u001b[0m\u001b[0m::Span::call_site()\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m224\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[38;5;10mproc_macro\u001b[0m\u001b[0m::Span::call_site()\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider importing this struct\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m38\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+ use proc_macro::Span;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: if you import `Span`, refer to it directly\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m224\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[38;5;9mproc_macro2::\u001b[0m\u001b[0mSpan::call_site()\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m224\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m        Span::call_site()\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of unresolved module or unlinked crate `proc_macro2`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":8503,"byte_end":8514,"line_start":269,"line_end":269,"column_start":9,"column_end":20,"is_primary":true,"text":[{"text":"        proc_macro2::Span::call_site()","highlight_start":9,"highlight_end":20}],"label":"use of unresolved module or unlinked crate `proc_macro2`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is a crate or module with a similar name","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":8503,"byte_end":8514,"line_start":269,"line_end":269,"column_start":9,"column_end":20,"is_primary":true,"text":[{"text":"        proc_macro2::Span::call_site()","highlight_start":9,"highlight_end":20}],"label":null,"suggested_replacement":"proc_macro","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":1275,"byte_end":1275,"line_start":38,"line_end":38,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::collections::HashMap;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use proc_macro::Span;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"if you import `Span`, refer to it directly","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":8503,"byte_end":8516,"line_start":269,"line_end":269,"column_start":9,"column_end":22,"is_primary":true,"text":[{"text":"        proc_macro2::Span::call_site()","highlight_start":9,"highlight_end":22}],"label":null,"suggested_replacement":"","suggestion_applicability":"Unspecified","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: use of unresolved module or unlinked crate `proc_macro2`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:269:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m269\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        proc_macro2::Span::call_site()\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of unresolved module or unlinked crate `proc_macro2`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: there is a crate or module with a similar name\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m269\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[38;5;9mproc_macro2\u001b[0m\u001b[0m::Span::call_site()\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m269\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[38;5;10mproc_macro\u001b[0m\u001b[0m::Span::call_site()\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider importing this struct\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m38\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+ use proc_macro::Span;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: if you import `Span`, refer to it directly\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m269\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[38;5;9mproc_macro2::\u001b[0m\u001b[0mSpan::call_site()\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m269\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0m        Span::call_site()\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"`ignore` is ambiguous","code":{"code":"E0659","explanation":"An item usage is ambiguous.\n\nErroneous code example:\n\n```compile_fail,edition2018,E0659\npub mod moon {\n    pub fn foo() {}\n}\n\npub mod earth {\n    pub fn foo() {}\n}\n\nmod collider {\n    pub use crate::moon::*;\n    pub use crate::earth::*;\n}\n\nfn main() {\n    crate::collider::foo(); // ERROR: `foo` is ambiguous\n}\n```\n\nThis error generally appears when two items with the same name are imported into\na module. Here, the `foo` functions are imported and reexported from the\n`collider` module and therefore, when we're using `collider::foo()`, both\nfunctions collide.\n\nTo solve this error, the best solution is generally to keep the path before the\nitem when using it. Example:\n\n```edition2018\npub mod moon {\n    pub fn foo() {}\n}\n\npub mod earth {\n    pub fn foo() {}\n}\n\nmod collider {\n    pub use crate::moon;\n    pub use crate::earth;\n}\n\nfn main() {\n    crate::collider::moon::foo(); // ok!\n    crate::collider::earth::foo(); // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":15360,"byte_end":15366,"line_start":450,"line_end":450,"column_start":7,"column_end":13,"is_primary":true,"text":[{"text":"    #[ignore(retry = 3)]","highlight_start":7,"highlight_end":13}],"label":"ambiguous name","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"ambiguous because of a name conflict with a builtin attribute","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"`ignore` could refer to a built-in attribute","code":null,"level":"note","spans":[{"file_name":"src/lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"`ignore` could also refer to the attribute macro imported here","code":null,"level":"note","spans":[{"file_name":"src/lib.rs","byte_start":15285,"byte_end":15293,"line_start":447,"line_end":447,"column_start":9,"column_end":17,"is_primary":true,"text":[{"text":"    use super::*;","highlight_start":9,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use `self::ignore` to refer to this attribute macro unambiguously","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0659]\u001b[0m\u001b[0m\u001b[1m: `ignore` is ambiguous\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:450:7\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m450\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    #[ignore(retry = 3)]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mambiguous name\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: ambiguous because of a name conflict with a builtin attribute\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `ignore` could refer to a built-in attribute\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `ignore` could also refer to the attribute macro imported here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:447:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m447\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    use super::*;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: use `self::ignore` to refer to this attribute macro unambiguously\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"valid forms for the attribute are `#[ignore]` and `#[ignore = \"reason\"]`","code":{"code":"ill_formed_attribute_input","explanation":null},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":15358,"byte_end":15378,"line_start":450,"line_end":450,"column_start":5,"column_end":25,"is_primary":true,"text":[{"text":"    #[ignore(retry = 3)]","highlight_start":5,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!","code":null,"level":"warning","spans":[],"children":[],"rendered":null},{"message":"for more information, see issue #57571 <https://github.com/rust-lang/rust/issues/57571>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"`#[deny(ill_formed_attribute_input)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: valid forms for the attribute are `#[ignore]` and `#[ignore = \"reason\"]`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:450:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m450\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    #[ignore(retry = 3)]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mwarning\u001b[0m\u001b[0m: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: for more information, see issue #57571 <https://github.com/rust-lang/rust/issues/57571>\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[deny(ill_formed_attribute_input)]` on by default\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot call non-const associated function `HashMap::<i32, usize>::new` in statics","code":{"code":"E0015","explanation":"A non-`const` function was called in a `const` context.\n\nErroneous code example:\n\n```compile_fail,E0015\nfn create_some() -> Option<u8> {\n    Some(1)\n}\n\n// error: cannot call non-const function `create_some` in constants\nconst FOO: Option<u8> = create_some();\n```\n\nAll functions used in a `const` context (constant or static expression) must\nbe marked `const`.\n\nTo fix this error, you can declare `create_some` as a constant function:\n\n```\n// declared as a `const` function:\nconst fn create_some() -> Option<u8> {\n    Some(1)\n}\n\nconst FOO: Option<u8> = create_some(); // no error!\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":15740,"byte_end":15772,"line_start":461,"line_end":461,"column_start":72,"column_end":104,"is_primary":true,"text":[{"text":"        static mut CALL_COUNT: std::collections::HashMap<i32, usize> = std::collections::HashMap::new();","highlight_start":72,"highlight_end":104}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"calls in statics are limited to constant functions, tuple structs and tuple variants","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider wrapping this expression in `std::sync::LazyLock::new(|| ...)`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0015]\u001b[0m\u001b[0m\u001b[1m: cannot call non-const associated function `HashMap::<i32, usize>::new` in statics\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:461:72\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m461\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        static mut CALL_COUNT: std::collections::HashMap<i32, usize> = std::collections::HashMap::new();\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: calls in statics are limited to constant functions, tuple structs and tuple variants\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: consider wrapping this expression in `std::sync::LazyLock::new(|| ...)`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `name`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/lib.rs","byte_start":14147,"byte_end":14151,"line_start":409,"line_end":409,"column_start":17,"column_end":21,"is_primary":true,"text":[{"text":"                name => {","highlight_start":17,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":10446,"byte_end":10477,"line_start":323,"line_end":323,"column_start":49,"column_end":80,"is_primary":false,"text":[{"text":"            let (name, retry_count, strategy) = pipex!(@get_fn_config $fn_name);","highlight_start":49,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":10015,"byte_end":10086,"line_start":314,"line_end":314,"column_start":13,"column_end":84,"is_primary":false,"text":[{"text":"            pipex!(@async_with_function_config input, $var, $fn_name, ($($args),*))","highlight_start":13,"highlight_end":84}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":9090,"byte_end":9130,"line_start":290,"line_end":290,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":16506,"byte_end":16610,"line_start":488,"line_end":491,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 3, 4, 5]","highlight_start":1,"highlight_end":32},{"text":"            => async? |x| process_with_ignore_retry(x)","highlight_start":1,"highlight_end":55},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"`#[warn(unused_variables)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":14147,"byte_end":14151,"line_start":409,"line_end":409,"column_start":17,"column_end":21,"is_primary":true,"text":[{"text":"                name => {","highlight_start":17,"highlight_end":21}],"label":null,"suggested_replacement":"_name","suggestion_applicability":"MaybeIncorrect","expansion":{"span":{"file_name":"src/lib.rs","byte_start":10446,"byte_end":10477,"line_start":323,"line_end":323,"column_start":49,"column_end":80,"is_primary":false,"text":[{"text":"            let (name, retry_count, strategy) = pipex!(@get_fn_config $fn_name);","highlight_start":49,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":10015,"byte_end":10086,"line_start":314,"line_end":314,"column_start":13,"column_end":84,"is_primary":false,"text":[{"text":"            pipex!(@async_with_function_config input, $var, $fn_name, ($($args),*))","highlight_start":13,"highlight_end":84}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":9090,"byte_end":9130,"line_start":290,"line_end":290,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":16506,"byte_end":16610,"line_start":488,"line_end":491,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 3, 4, 5]","highlight_start":1,"highlight_end":32},{"text":"            => async? |x| process_with_ignore_retry(x)","highlight_start":1,"highlight_end":55},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused variable: `name`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:409:17\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m409\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                name => {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_name`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m488\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        let result = pipex!(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m ______________________-\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m489\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            vec![1, 2, 3, 4, 5]\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m490\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            => async? |x| process_with_ignore_retry(x)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m491\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        );\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_variables)]` on by default\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this warning originates in the macro `pipex` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `name`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/lib.rs","byte_start":14147,"byte_end":14151,"line_start":409,"line_end":409,"column_start":17,"column_end":21,"is_primary":true,"text":[{"text":"                name => {","highlight_start":17,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":10446,"byte_end":10477,"line_start":323,"line_end":323,"column_start":49,"column_end":80,"is_primary":false,"text":[{"text":"            let (name, retry_count, strategy) = pipex!(@get_fn_config $fn_name);","highlight_start":49,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":10015,"byte_end":10086,"line_start":314,"line_end":314,"column_start":13,"column_end":84,"is_primary":false,"text":[{"text":"            pipex!(@async_with_function_config input, $var, $fn_name, ($($args),*))","highlight_start":13,"highlight_end":84}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":9090,"byte_end":9130,"line_start":290,"line_end":290,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":16816,"byte_end":16918,"line_start":499,"line_end":502,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 3, 4]","highlight_start":1,"highlight_end":29},{"text":"            => async? |x| process_with_collect_retry(x)","highlight_start":1,"highlight_end":56},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":14147,"byte_end":14151,"line_start":409,"line_end":409,"column_start":17,"column_end":21,"is_primary":true,"text":[{"text":"                name => {","highlight_start":17,"highlight_end":21}],"label":null,"suggested_replacement":"_name","suggestion_applicability":"MaybeIncorrect","expansion":{"span":{"file_name":"src/lib.rs","byte_start":10446,"byte_end":10477,"line_start":323,"line_end":323,"column_start":49,"column_end":80,"is_primary":false,"text":[{"text":"            let (name, retry_count, strategy) = pipex!(@get_fn_config $fn_name);","highlight_start":49,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":10015,"byte_end":10086,"line_start":314,"line_end":314,"column_start":13,"column_end":84,"is_primary":false,"text":[{"text":"            pipex!(@async_with_function_config input, $var, $fn_name, ($($args),*))","highlight_start":13,"highlight_end":84}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":9090,"byte_end":9130,"line_start":290,"line_end":290,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":16816,"byte_end":16918,"line_start":499,"line_end":502,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 3, 4]","highlight_start":1,"highlight_end":29},{"text":"            => async? |x| process_with_collect_retry(x)","highlight_start":1,"highlight_end":56},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused variable: `name`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:409:17\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m409\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                name => {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_name`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m499\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        let result = pipex!(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m ______________________-\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m500\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            vec![1, 2, 3, 4]\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m501\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            => async? |x| process_with_collect_retry(x)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m502\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        );\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this warning originates in the macro `pipex` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `name`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/lib.rs","byte_start":14147,"byte_end":14151,"line_start":409,"line_end":409,"column_start":17,"column_end":21,"is_primary":true,"text":[{"text":"                name => {","highlight_start":17,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":10446,"byte_end":10477,"line_start":323,"line_end":323,"column_start":49,"column_end":80,"is_primary":false,"text":[{"text":"            let (name, retry_count, strategy) = pipex!(@get_fn_config $fn_name);","highlight_start":49,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":10015,"byte_end":10086,"line_start":314,"line_end":314,"column_start":13,"column_end":84,"is_primary":false,"text":[{"text":"            pipex!(@async_with_function_config input, $var, $fn_name, ($($args),*))","highlight_start":13,"highlight_end":84}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":9090,"byte_end":9130,"line_start":290,"line_end":290,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":17336,"byte_end":17440,"line_start":514,"line_end":517,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 4, 5]","highlight_start":1,"highlight_end":29},{"text":"            => async? |x| process_with_fail_fast_retry(x)","highlight_start":1,"highlight_end":58},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":14147,"byte_end":14151,"line_start":409,"line_end":409,"column_start":17,"column_end":21,"is_primary":true,"text":[{"text":"                name => {","highlight_start":17,"highlight_end":21}],"label":null,"suggested_replacement":"_name","suggestion_applicability":"MaybeIncorrect","expansion":{"span":{"file_name":"src/lib.rs","byte_start":10446,"byte_end":10477,"line_start":323,"line_end":323,"column_start":49,"column_end":80,"is_primary":false,"text":[{"text":"            let (name, retry_count, strategy) = pipex!(@get_fn_config $fn_name);","highlight_start":49,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":10015,"byte_end":10086,"line_start":314,"line_end":314,"column_start":13,"column_end":84,"is_primary":false,"text":[{"text":"            pipex!(@async_with_function_config input, $var, $fn_name, ($($args),*))","highlight_start":13,"highlight_end":84}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":9090,"byte_end":9130,"line_start":290,"line_end":290,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":17336,"byte_end":17440,"line_start":514,"line_end":517,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 4, 5]","highlight_start":1,"highlight_end":29},{"text":"            => async? |x| process_with_fail_fast_retry(x)","highlight_start":1,"highlight_end":58},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused variable: `name`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:409:17\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m409\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                name => {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_name`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m514\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        let result = pipex!(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m ______________________-\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m515\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            vec![1, 2, 4, 5]\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m516\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            => async? |x| process_with_fail_fast_retry(x)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m517\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        );\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this warning originates in the macro `pipex` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no field `lit` on type `MetaNameValue`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":4863,"byte_end":4866,"line_start":160,"line_end":160,"column_start":47,"column_end":50,"is_primary":true,"text":[{"text":"                if let Lit::Int(lit_int) = nv.lit {","highlight_start":47,"highlight_end":50}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `path`, `eq_token`, `value`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0609]\u001b[0m\u001b[0m\u001b[1m: no field `lit` on type `MetaNameValue`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:160:47\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m160\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                if let Lit::Int(lit_int) = nv.lit {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9munknown field\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: available fields are: `path`, `eq_token`, `value`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no field `lit` on type `MetaNameValue`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":6515,"byte_end":6518,"line_start":208,"line_end":208,"column_start":47,"column_end":50,"is_primary":true,"text":[{"text":"                if let Lit::Int(lit_int) = nv.lit {","highlight_start":47,"highlight_end":50}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `path`, `eq_token`, `value`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0609]\u001b[0m\u001b[0m\u001b[1m: no field `lit` on type `MetaNameValue`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:208:47\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m208\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                if let Lit::Int(lit_int) = nv.lit {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9munknown field\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: available fields are: `path`, `eq_token`, `value`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no field `lit` on type `MetaNameValue`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":8009,"byte_end":8012,"line_start":253,"line_end":253,"column_start":47,"column_end":50,"is_primary":true,"text":[{"text":"                if let Lit::Int(lit_int) = nv.lit {","highlight_start":47,"highlight_end":50}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `path`, `eq_token`, `value`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0609]\u001b[0m\u001b[0m\u001b[1m: no field `lit` on type `MetaNameValue`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:253:47\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m253\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                if let Lit::Int(lit_int) = nv.lit {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9munknown field\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: available fields are: `path`, `eq_token`, `value`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"`match` arms have incompatible types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":12554,"byte_end":12610,"line_start":370,"line_end":370,"column_start":21,"column_end":77,"is_primary":true,"text":[{"text":"                    $crate::CollectHandler.handle_results(all_results).await","highlight_start":21,"highlight_end":77}],"label":"expected `Vec<i32>`, found `Vec<Result<i32, String>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":10015,"byte_end":10086,"line_start":314,"line_end":314,"column_start":13,"column_end":84,"is_primary":false,"text":[{"text":"            pipex!(@async_with_function_config input, $var, $fn_name, ($($args),*))","highlight_start":13,"highlight_end":84}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":9090,"byte_end":9130,"line_start":290,"line_end":290,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":16506,"byte_end":16610,"line_start":488,"line_end":491,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 3, 4, 5]","highlight_start":1,"highlight_end":32},{"text":"            => async? |x| process_with_ignore_retry(x)","highlight_start":1,"highlight_end":55},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":11436,"byte_end":11491,"line_start":346,"line_end":346,"column_start":21,"column_end":76,"is_primary":false,"text":[{"text":"                    $crate::IgnoreHandler.handle_results(all_results).await","highlight_start":21,"highlight_end":76}],"label":"this is found to be of type `Vec<i32>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":10015,"byte_end":10086,"line_start":314,"line_end":314,"column_start":13,"column_end":84,"is_primary":false,"text":[{"text":"            pipex!(@async_with_function_config input, $var, $fn_name, ($($args),*))","highlight_start":13,"highlight_end":84}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":9090,"byte_end":9130,"line_start":290,"line_end":290,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":16506,"byte_end":16610,"line_start":488,"line_end":491,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 3, 4, 5]","highlight_start":1,"highlight_end":32},{"text":"            => async? |x| process_with_ignore_retry(x)","highlight_start":1,"highlight_end":55},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":10504,"byte_end":13763,"line_start":325,"line_end":398,"column_start":13,"column_end":14,"is_primary":false,"text":[{"text":"            match strategy {","highlight_start":13,"highlight_end":29},{"text":"                \"ignore\" => {","highlight_start":1,"highlight_end":30},{"text":"                    let mut all_results = Vec::new();","highlight_start":1,"highlight_end":54},{"text":"                    for item in $input {","highlight_start":1,"highlight_end":41},{"text":"                        let $var = item;","highlight_start":1,"highlight_end":41},{"text":"                        let mut attempts = 0;","highlight_start":1,"highlight_end":46},{"text":"                        while attempts < retry_count {","highlight_start":1,"highlight_end":55},{"text":"                            match $fn_name($($args),*).await {","highlight_start":1,"highlight_end":63},{"text":"                                Ok(value) => {","highlight_start":1,"highlight_end":47},{"text":"                                    all_results.push(Ok(value));","highlight_start":1,"highlight_end":65},{"text":"                                    break;","highlight_start":1,"highlight_end":43},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                                Err(e) => {","highlight_start":1,"highlight_end":44},{"text":"                                    attempts += 1;","highlight_start":1,"highlight_end":51},{"text":"                                    if attempts >= retry_count {","highlight_start":1,"highlight_end":65},{"text":"                                        all_results.push(Err(e));","highlight_start":1,"highlight_end":66},{"text":"                                    }","highlight_start":1,"highlight_end":38},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    $crate::IgnoreHandler.handle_results(all_results).await","highlight_start":1,"highlight_end":76},{"text":"                },","highlight_start":1,"highlight_end":19},{"text":"                \"collect\" => {","highlight_start":1,"highlight_end":31},{"text":"                    let mut all_results = Vec::new();","highlight_start":1,"highlight_end":54},{"text":"                    for item in $input {","highlight_start":1,"highlight_end":41},{"text":"                        let $var = item;","highlight_start":1,"highlight_end":41},{"text":"                        let mut attempts = 0;","highlight_start":1,"highlight_end":46},{"text":"                        let mut last_error = None;","highlight_start":1,"highlight_end":51},{"text":"                        while attempts < retry_count {","highlight_start":1,"highlight_end":55},{"text":"                            match $fn_name($($args),*).await {","highlight_start":1,"highlight_end":63},{"text":"                                Ok(value) => {","highlight_start":1,"highlight_end":47},{"text":"                                    all_results.push(Ok(value));","highlight_start":1,"highlight_end":65},{"text":"                                    break;","highlight_start":1,"highlight_end":43},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                                Err(e) => {","highlight_start":1,"highlight_end":44},{"text":"                                    attempts += 1;","highlight_start":1,"highlight_end":51},{"text":"                                    last_error = Some(e);","highlight_start":1,"highlight_end":58},{"text":"                                    if attempts >= retry_count {","highlight_start":1,"highlight_end":65},{"text":"                                        all_results.push(Err(last_error.unwrap()));","highlight_start":1,"highlight_end":84},{"text":"                                    }","highlight_start":1,"highlight_end":38},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    $crate::CollectHandler.handle_results(all_results).await","highlight_start":1,"highlight_end":77},{"text":"                },","highlight_start":1,"highlight_end":19},{"text":"                _ => {","highlight_start":1,"highlight_end":23},{"text":"                    // Default: fail_fast with retry","highlight_start":1,"highlight_end":53},{"text":"                    let mut results = Vec::new();","highlight_start":1,"highlight_end":50},{"text":"                    for item in $input {","highlight_start":1,"highlight_end":41},{"text":"                        let $var = item;","highlight_start":1,"highlight_end":41},{"text":"                        let mut attempts = 0;","highlight_start":1,"highlight_end":46},{"text":"                        let mut last_error = None;","highlight_start":1,"highlight_end":51},{"text":"                        ","highlight_start":1,"highlight_end":25},{"text":"                        while attempts < retry_count {","highlight_start":1,"highlight_end":55},{"text":"                            match $fn_name($($args),*).await {","highlight_start":1,"highlight_end":63},{"text":"                                Ok(value) => {","highlight_start":1,"highlight_end":47},{"text":"                                    results.push(value);","highlight_start":1,"highlight_end":57},{"text":"                                    break;","highlight_start":1,"highlight_end":43},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                                Err(e) => {","highlight_start":1,"highlight_end":44},{"text":"                                    attempts += 1;","highlight_start":1,"highlight_end":51},{"text":"                                    last_error = Some(e);","highlight_start":1,"highlight_end":58},{"text":"                                    if attempts >= retry_count {","highlight_start":1,"highlight_end":65},{"text":"                                        return Err(last_error.unwrap());","highlight_start":1,"highlight_end":73},{"text":"                                    }","highlight_start":1,"highlight_end":38},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    Ok(results)","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14}],"label":"`match` arms have incompatible types","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":10015,"byte_end":10086,"line_start":314,"line_end":314,"column_start":13,"column_end":84,"is_primary":false,"text":[{"text":"            pipex!(@async_with_function_config input, $var, $fn_name, ($($args),*))","highlight_start":13,"highlight_end":84}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":9090,"byte_end":9130,"line_start":290,"line_end":290,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":16506,"byte_end":16610,"line_start":488,"line_end":491,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 3, 4, 5]","highlight_start":1,"highlight_end":32},{"text":"            => async? |x| process_with_ignore_retry(x)","highlight_start":1,"highlight_end":55},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected struct `Vec<i32>`\n   found struct `Vec<Result<i32, std::string::String>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: `match` arms have incompatible types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:370:21\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m325\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m            match strategy {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m326\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                \"ignore\" => {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m327\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    let mut all_results = Vec::new();\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m328\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    for item in $input {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m346\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    $crate::IgnoreHandler.handle_results(all_results).await\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis is found to be of type `Vec<i32>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m370\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    $crate::CollectHandler.handle_results(all_results).await\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `Vec<i32>`, found `Vec<Result<i32, String>>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m398\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_____________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m`match` arms have incompatible types\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m488\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        let result = pipex!(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m ______________________-\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m489\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            vec![1, 2, 3, 4, 5]\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m490\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            => async? |x| process_with_ignore_retry(x)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m491\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        );\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected struct `Vec<\u001b[0m\u001b[0m\u001b[1m\u001b[35mi32\u001b[0m\u001b[0m>`\u001b[0m\n\u001b[0m               found struct `Vec<\u001b[0m\u001b[0m\u001b[1m\u001b[35mResult<i32, std::string::String>\u001b[0m\u001b[0m>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `pipex` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"`match` arms have incompatible types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":12554,"byte_end":12610,"line_start":370,"line_end":370,"column_start":21,"column_end":77,"is_primary":true,"text":[{"text":"                    $crate::CollectHandler.handle_results(all_results).await","highlight_start":21,"highlight_end":77}],"label":"expected `Vec<i32>`, found `Vec<Result<i32, String>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":10015,"byte_end":10086,"line_start":314,"line_end":314,"column_start":13,"column_end":84,"is_primary":false,"text":[{"text":"            pipex!(@async_with_function_config input, $var, $fn_name, ($($args),*))","highlight_start":13,"highlight_end":84}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":9090,"byte_end":9130,"line_start":290,"line_end":290,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":16816,"byte_end":16918,"line_start":499,"line_end":502,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 3, 4]","highlight_start":1,"highlight_end":29},{"text":"            => async? |x| process_with_collect_retry(x)","highlight_start":1,"highlight_end":56},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":11436,"byte_end":11491,"line_start":346,"line_end":346,"column_start":21,"column_end":76,"is_primary":false,"text":[{"text":"                    $crate::IgnoreHandler.handle_results(all_results).await","highlight_start":21,"highlight_end":76}],"label":"this is found to be of type `Vec<i32>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":10015,"byte_end":10086,"line_start":314,"line_end":314,"column_start":13,"column_end":84,"is_primary":false,"text":[{"text":"            pipex!(@async_with_function_config input, $var, $fn_name, ($($args),*))","highlight_start":13,"highlight_end":84}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":9090,"byte_end":9130,"line_start":290,"line_end":290,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":16816,"byte_end":16918,"line_start":499,"line_end":502,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 3, 4]","highlight_start":1,"highlight_end":29},{"text":"            => async? |x| process_with_collect_retry(x)","highlight_start":1,"highlight_end":56},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":10504,"byte_end":13763,"line_start":325,"line_end":398,"column_start":13,"column_end":14,"is_primary":false,"text":[{"text":"            match strategy {","highlight_start":13,"highlight_end":29},{"text":"                \"ignore\" => {","highlight_start":1,"highlight_end":30},{"text":"                    let mut all_results = Vec::new();","highlight_start":1,"highlight_end":54},{"text":"                    for item in $input {","highlight_start":1,"highlight_end":41},{"text":"                        let $var = item;","highlight_start":1,"highlight_end":41},{"text":"                        let mut attempts = 0;","highlight_start":1,"highlight_end":46},{"text":"                        while attempts < retry_count {","highlight_start":1,"highlight_end":55},{"text":"                            match $fn_name($($args),*).await {","highlight_start":1,"highlight_end":63},{"text":"                                Ok(value) => {","highlight_start":1,"highlight_end":47},{"text":"                                    all_results.push(Ok(value));","highlight_start":1,"highlight_end":65},{"text":"                                    break;","highlight_start":1,"highlight_end":43},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                                Err(e) => {","highlight_start":1,"highlight_end":44},{"text":"                                    attempts += 1;","highlight_start":1,"highlight_end":51},{"text":"                                    if attempts >= retry_count {","highlight_start":1,"highlight_end":65},{"text":"                                        all_results.push(Err(e));","highlight_start":1,"highlight_end":66},{"text":"                                    }","highlight_start":1,"highlight_end":38},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    $crate::IgnoreHandler.handle_results(all_results).await","highlight_start":1,"highlight_end":76},{"text":"                },","highlight_start":1,"highlight_end":19},{"text":"                \"collect\" => {","highlight_start":1,"highlight_end":31},{"text":"                    let mut all_results = Vec::new();","highlight_start":1,"highlight_end":54},{"text":"                    for item in $input {","highlight_start":1,"highlight_end":41},{"text":"                        let $var = item;","highlight_start":1,"highlight_end":41},{"text":"                        let mut attempts = 0;","highlight_start":1,"highlight_end":46},{"text":"                        let mut last_error = None;","highlight_start":1,"highlight_end":51},{"text":"                        while attempts < retry_count {","highlight_start":1,"highlight_end":55},{"text":"                            match $fn_name($($args),*).await {","highlight_start":1,"highlight_end":63},{"text":"                                Ok(value) => {","highlight_start":1,"highlight_end":47},{"text":"                                    all_results.push(Ok(value));","highlight_start":1,"highlight_end":65},{"text":"                                    break;","highlight_start":1,"highlight_end":43},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                                Err(e) => {","highlight_start":1,"highlight_end":44},{"text":"                                    attempts += 1;","highlight_start":1,"highlight_end":51},{"text":"                                    last_error = Some(e);","highlight_start":1,"highlight_end":58},{"text":"                                    if attempts >= retry_count {","highlight_start":1,"highlight_end":65},{"text":"                                        all_results.push(Err(last_error.unwrap()));","highlight_start":1,"highlight_end":84},{"text":"                                    }","highlight_start":1,"highlight_end":38},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    $crate::CollectHandler.handle_results(all_results).await","highlight_start":1,"highlight_end":77},{"text":"                },","highlight_start":1,"highlight_end":19},{"text":"                _ => {","highlight_start":1,"highlight_end":23},{"text":"                    // Default: fail_fast with retry","highlight_start":1,"highlight_end":53},{"text":"                    let mut results = Vec::new();","highlight_start":1,"highlight_end":50},{"text":"                    for item in $input {","highlight_start":1,"highlight_end":41},{"text":"                        let $var = item;","highlight_start":1,"highlight_end":41},{"text":"                        let mut attempts = 0;","highlight_start":1,"highlight_end":46},{"text":"                        let mut last_error = None;","highlight_start":1,"highlight_end":51},{"text":"                        ","highlight_start":1,"highlight_end":25},{"text":"                        while attempts < retry_count {","highlight_start":1,"highlight_end":55},{"text":"                            match $fn_name($($args),*).await {","highlight_start":1,"highlight_end":63},{"text":"                                Ok(value) => {","highlight_start":1,"highlight_end":47},{"text":"                                    results.push(value);","highlight_start":1,"highlight_end":57},{"text":"                                    break;","highlight_start":1,"highlight_end":43},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                                Err(e) => {","highlight_start":1,"highlight_end":44},{"text":"                                    attempts += 1;","highlight_start":1,"highlight_end":51},{"text":"                                    last_error = Some(e);","highlight_start":1,"highlight_end":58},{"text":"                                    if attempts >= retry_count {","highlight_start":1,"highlight_end":65},{"text":"                                        return Err(last_error.unwrap());","highlight_start":1,"highlight_end":73},{"text":"                                    }","highlight_start":1,"highlight_end":38},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    Ok(results)","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14}],"label":"`match` arms have incompatible types","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":10015,"byte_end":10086,"line_start":314,"line_end":314,"column_start":13,"column_end":84,"is_primary":false,"text":[{"text":"            pipex!(@async_with_function_config input, $var, $fn_name, ($($args),*))","highlight_start":13,"highlight_end":84}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":9090,"byte_end":9130,"line_start":290,"line_end":290,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":16816,"byte_end":16918,"line_start":499,"line_end":502,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 3, 4]","highlight_start":1,"highlight_end":29},{"text":"            => async? |x| process_with_collect_retry(x)","highlight_start":1,"highlight_end":56},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected struct `Vec<i32>`\n   found struct `Vec<Result<i32, std::string::String>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: `match` arms have incompatible types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:370:21\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m325\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m            match strategy {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m326\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                \"ignore\" => {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m327\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    let mut all_results = Vec::new();\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m328\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    for item in $input {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m346\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    $crate::IgnoreHandler.handle_results(all_results).await\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis is found to be of type `Vec<i32>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m370\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    $crate::CollectHandler.handle_results(all_results).await\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `Vec<i32>`, found `Vec<Result<i32, String>>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m398\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_____________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m`match` arms have incompatible types\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m499\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        let result = pipex!(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m ______________________-\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m500\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            vec![1, 2, 3, 4]\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m501\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            => async? |x| process_with_collect_retry(x)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m502\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        );\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected struct `Vec<\u001b[0m\u001b[0m\u001b[1m\u001b[35mi32\u001b[0m\u001b[0m>`\u001b[0m\n\u001b[0m               found struct `Vec<\u001b[0m\u001b[0m\u001b[1m\u001b[35mResult<i32, std::string::String>\u001b[0m\u001b[0m>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `pipex` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"`match` arms have incompatible types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":12554,"byte_end":12610,"line_start":370,"line_end":370,"column_start":21,"column_end":77,"is_primary":true,"text":[{"text":"                    $crate::CollectHandler.handle_results(all_results).await","highlight_start":21,"highlight_end":77}],"label":"expected `Vec<i32>`, found `Vec<Result<i32, String>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":10015,"byte_end":10086,"line_start":314,"line_end":314,"column_start":13,"column_end":84,"is_primary":false,"text":[{"text":"            pipex!(@async_with_function_config input, $var, $fn_name, ($($args),*))","highlight_start":13,"highlight_end":84}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":9090,"byte_end":9130,"line_start":290,"line_end":290,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":17336,"byte_end":17440,"line_start":514,"line_end":517,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 4, 5]","highlight_start":1,"highlight_end":29},{"text":"            => async? |x| process_with_fail_fast_retry(x)","highlight_start":1,"highlight_end":58},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":11436,"byte_end":11491,"line_start":346,"line_end":346,"column_start":21,"column_end":76,"is_primary":false,"text":[{"text":"                    $crate::IgnoreHandler.handle_results(all_results).await","highlight_start":21,"highlight_end":76}],"label":"this is found to be of type `Vec<i32>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":10015,"byte_end":10086,"line_start":314,"line_end":314,"column_start":13,"column_end":84,"is_primary":false,"text":[{"text":"            pipex!(@async_with_function_config input, $var, $fn_name, ($($args),*))","highlight_start":13,"highlight_end":84}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":9090,"byte_end":9130,"line_start":290,"line_end":290,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":17336,"byte_end":17440,"line_start":514,"line_end":517,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 4, 5]","highlight_start":1,"highlight_end":29},{"text":"            => async? |x| process_with_fail_fast_retry(x)","highlight_start":1,"highlight_end":58},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":10504,"byte_end":13763,"line_start":325,"line_end":398,"column_start":13,"column_end":14,"is_primary":false,"text":[{"text":"            match strategy {","highlight_start":13,"highlight_end":29},{"text":"                \"ignore\" => {","highlight_start":1,"highlight_end":30},{"text":"                    let mut all_results = Vec::new();","highlight_start":1,"highlight_end":54},{"text":"                    for item in $input {","highlight_start":1,"highlight_end":41},{"text":"                        let $var = item;","highlight_start":1,"highlight_end":41},{"text":"                        let mut attempts = 0;","highlight_start":1,"highlight_end":46},{"text":"                        while attempts < retry_count {","highlight_start":1,"highlight_end":55},{"text":"                            match $fn_name($($args),*).await {","highlight_start":1,"highlight_end":63},{"text":"                                Ok(value) => {","highlight_start":1,"highlight_end":47},{"text":"                                    all_results.push(Ok(value));","highlight_start":1,"highlight_end":65},{"text":"                                    break;","highlight_start":1,"highlight_end":43},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                                Err(e) => {","highlight_start":1,"highlight_end":44},{"text":"                                    attempts += 1;","highlight_start":1,"highlight_end":51},{"text":"                                    if attempts >= retry_count {","highlight_start":1,"highlight_end":65},{"text":"                                        all_results.push(Err(e));","highlight_start":1,"highlight_end":66},{"text":"                                    }","highlight_start":1,"highlight_end":38},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    $crate::IgnoreHandler.handle_results(all_results).await","highlight_start":1,"highlight_end":76},{"text":"                },","highlight_start":1,"highlight_end":19},{"text":"                \"collect\" => {","highlight_start":1,"highlight_end":31},{"text":"                    let mut all_results = Vec::new();","highlight_start":1,"highlight_end":54},{"text":"                    for item in $input {","highlight_start":1,"highlight_end":41},{"text":"                        let $var = item;","highlight_start":1,"highlight_end":41},{"text":"                        let mut attempts = 0;","highlight_start":1,"highlight_end":46},{"text":"                        let mut last_error = None;","highlight_start":1,"highlight_end":51},{"text":"                        while attempts < retry_count {","highlight_start":1,"highlight_end":55},{"text":"                            match $fn_name($($args),*).await {","highlight_start":1,"highlight_end":63},{"text":"                                Ok(value) => {","highlight_start":1,"highlight_end":47},{"text":"                                    all_results.push(Ok(value));","highlight_start":1,"highlight_end":65},{"text":"                                    break;","highlight_start":1,"highlight_end":43},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                                Err(e) => {","highlight_start":1,"highlight_end":44},{"text":"                                    attempts += 1;","highlight_start":1,"highlight_end":51},{"text":"                                    last_error = Some(e);","highlight_start":1,"highlight_end":58},{"text":"                                    if attempts >= retry_count {","highlight_start":1,"highlight_end":65},{"text":"                                        all_results.push(Err(last_error.unwrap()));","highlight_start":1,"highlight_end":84},{"text":"                                    }","highlight_start":1,"highlight_end":38},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    $crate::CollectHandler.handle_results(all_results).await","highlight_start":1,"highlight_end":77},{"text":"                },","highlight_start":1,"highlight_end":19},{"text":"                _ => {","highlight_start":1,"highlight_end":23},{"text":"                    // Default: fail_fast with retry","highlight_start":1,"highlight_end":53},{"text":"                    let mut results = Vec::new();","highlight_start":1,"highlight_end":50},{"text":"                    for item in $input {","highlight_start":1,"highlight_end":41},{"text":"                        let $var = item;","highlight_start":1,"highlight_end":41},{"text":"                        let mut attempts = 0;","highlight_start":1,"highlight_end":46},{"text":"                        let mut last_error = None;","highlight_start":1,"highlight_end":51},{"text":"                        ","highlight_start":1,"highlight_end":25},{"text":"                        while attempts < retry_count {","highlight_start":1,"highlight_end":55},{"text":"                            match $fn_name($($args),*).await {","highlight_start":1,"highlight_end":63},{"text":"                                Ok(value) => {","highlight_start":1,"highlight_end":47},{"text":"                                    results.push(value);","highlight_start":1,"highlight_end":57},{"text":"                                    break;","highlight_start":1,"highlight_end":43},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                                Err(e) => {","highlight_start":1,"highlight_end":44},{"text":"                                    attempts += 1;","highlight_start":1,"highlight_end":51},{"text":"                                    last_error = Some(e);","highlight_start":1,"highlight_end":58},{"text":"                                    if attempts >= retry_count {","highlight_start":1,"highlight_end":65},{"text":"                                        return Err(last_error.unwrap());","highlight_start":1,"highlight_end":73},{"text":"                                    }","highlight_start":1,"highlight_end":38},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    Ok(results)","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14}],"label":"`match` arms have incompatible types","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":10015,"byte_end":10086,"line_start":314,"line_end":314,"column_start":13,"column_end":84,"is_primary":false,"text":[{"text":"            pipex!(@async_with_function_config input, $var, $fn_name, ($($args),*))","highlight_start":13,"highlight_end":84}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":9090,"byte_end":9130,"line_start":290,"line_end":290,"column_start":9,"column_end":49,"is_primary":false,"text":[{"text":"        pipex!(@process $input $(=> $($rest)+)?)","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":17336,"byte_end":17440,"line_start":514,"line_end":517,"column_start":22,"column_end":10,"is_primary":false,"text":[{"text":"        let result = pipex!(","highlight_start":22,"highlight_end":29},{"text":"            vec![1, 2, 4, 5]","highlight_start":1,"highlight_end":29},{"text":"            => async? |x| process_with_fail_fast_retry(x)","highlight_start":1,"highlight_end":58},{"text":"        );","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"pipex!","def_site_span":{"file_name":"src/lib.rs","byte_start":8998,"byte_end":9016,"line_start":287,"line_end":287,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! pipex {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected struct `Vec<i32>`\n   found struct `Vec<Result<i32, std::string::String>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: `match` arms have incompatible types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:370:21\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m325\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m            match strategy {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m326\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                \"ignore\" => {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m327\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    let mut all_results = Vec::new();\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m328\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    for item in $input {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m346\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    $crate::IgnoreHandler.handle_results(all_results).await\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis is found to be of type `Vec<i32>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m370\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    $crate::CollectHandler.handle_results(all_results).await\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `Vec<i32>`, found `Vec<Result<i32, String>>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m398\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_____________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m`match` arms have incompatible types\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m514\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        let result = pipex!(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m ______________________-\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m515\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            vec![1, 2, 4, 5]\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m516\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            => async? |x| process_with_fail_fast_retry(x)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m517\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        );\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected struct `Vec<\u001b[0m\u001b[0m\u001b[1m\u001b[35mi32\u001b[0m\u001b[0m>`\u001b[0m\n\u001b[0m               found struct `Vec<\u001b[0m\u001b[0m\u001b[1m\u001b[35mResult<i32, std::string::String>\u001b[0m\u001b[0m>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `pipex` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"can't compare `Vec<_>` with `Result<Vec<{integer}>, _>`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/dransy/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1485,"byte_end":1487,"line_start":46,"line_end":46,"column_start":32,"column_end":34,"is_primary":true,"text":[{"text":"                if !(*left_val == *right_val) {","highlight_start":32,"highlight_end":34}],"label":"no implementation for `Vec<_> == Result<Vec<{integer}>, _>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":17515,"byte_end":17557,"line_start":520,"line_end":520,"column_start":9,"column_end":51,"is_primary":false,"text":[{"text":"        assert_eq!(result, Ok(vec![3, 6, 12, 15]));","highlight_start":9,"highlight_end":51}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"assert_eq!","def_site_span":{"file_name":"/Users/dransy/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1315,"byte_end":1337,"line_start":42,"line_end":42,"column_start":1,"column_end":23,"is_primary":false,"text":[{"text":"macro_rules! assert_eq {","highlight_start":1,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `PartialEq<Result<Vec<{integer}>, _>>` is not implemented for `Vec<_>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `PartialEq<Rhs>`:\n  `Vec<T, A1>` implements `PartialEq<Vec<U, A2>>`\n  `Vec<T, A>` implements `PartialEq<&[U; N]>`\n  `Vec<T, A>` implements `PartialEq<&[U]>`\n  `Vec<T, A>` implements `PartialEq<&mut [U]>`\n  `Vec<T, A>` implements `PartialEq<[U; N]>`\n  `Vec<T, A>` implements `PartialEq<[U]>`\n  `Vec<u8>` implements `PartialEq<ByteString>`\n  `Vec<u8>` implements `PartialEq<bytes::bytes::Bytes>`\nand 2 others","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: can't compare `Vec<_>` with `Result<Vec<{integer}>, _>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:520:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m520\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        assert_eq!(result, Ok(vec![3, 6, 12, 15]));\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mno implementation for `Vec<_> == Result<Vec<{integer}>, _>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `PartialEq<Result<Vec<{integer}>, _>>` is not implemented for `Vec<_>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `PartialEq<Rhs>`:\u001b[0m\n\u001b[0m              `Vec<T, A1>` implements `PartialEq<Vec<U, A2>>`\u001b[0m\n\u001b[0m              `Vec<T, A>` implements `PartialEq<&[U; N]>`\u001b[0m\n\u001b[0m              `Vec<T, A>` implements `PartialEq<&[U]>`\u001b[0m\n\u001b[0m              `Vec<T, A>` implements `PartialEq<&mut [U]>`\u001b[0m\n\u001b[0m              `Vec<T, A>` implements `PartialEq<[U; N]>`\u001b[0m\n\u001b[0m              `Vec<T, A>` implements `PartialEq<[U]>`\u001b[0m\n\u001b[0m              `Vec<u8>` implements `PartialEq<ByteString>`\u001b[0m\n\u001b[0m              `Vec<u8>` implements `PartialEq<bytes::bytes::Bytes>`\u001b[0m\n\u001b[0m            and 2 others\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the parameter type `T` may not live long enough","code":{"code":"E0309","explanation":"A parameter type is missing an explicit lifetime bound and may not live long\nenough.\n\nErroneous code example:\n\n```compile_fail,E0309\n// This won't compile because the applicable impl of\n// `SomeTrait` (below) requires that `T: 'a`, but the struct does\n// not have a matching where-clause.\nstruct Foo<'a, T> {\n    foo: <T as SomeTrait<'a>>::Output,\n}\n\ntrait SomeTrait<'a> {\n    type Output;\n}\n\nimpl<'a, T> SomeTrait<'a> for T\nwhere\n    T: 'a,\n{\n    type Output = u32;\n}\n```\n\nThe type definition contains some field whose type requires an outlives\nannotation. Outlives annotations (e.g., `T: 'a`) are used to guarantee that all\nthe data in `T` is valid for at least the lifetime `'a`. This scenario most\ncommonly arises when the type contains an associated type reference like\n`<T as SomeTrait<'a>>::Output`, as shown in the previous code.\n\nThere, the where clause `T: 'a` that appears on the impl is not known to be\nsatisfied on the struct. To make this example compile, you have to add a\nwhere-clause like `T: 'a` to the struct definition:\n\n```\nstruct Foo<'a, T>\nwhere\n    T: 'a,\n{\n    foo: <T as SomeTrait<'a>>::Output\n}\n\ntrait SomeTrait<'a> {\n    type Output;\n}\n\nimpl<'a, T> SomeTrait<'a> for T\nwhere\n    T: 'a,\n{\n    type Output = u32;\n}\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":1878,"byte_end":1892,"line_start":62,"line_end":62,"column_start":1,"column_end":15,"is_primary":false,"text":[{"text":"#[async_trait]","highlight_start":1,"highlight_end":15}],"label":"the parameter type `T` must be valid for the lifetime `'async_trait` as defined here...","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":1878,"byte_end":1892,"line_start":62,"line_end":62,"column_start":1,"column_end":15,"is_primary":false,"text":[{"text":"#[async_trait]","highlight_start":1,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[async_trait]","def_site_span":{"file_name":"/Users/dransy/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/async-trait-0.1.88/src/lib.rs","byte_start":7473,"byte_end":7545,"line_start":252,"line_end":252,"column_start":1,"column_end":73,"is_primary":false,"text":[{"text":"pub fn async_trait(args: TokenStream, input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":73}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":2054,"byte_end":2122,"line_start":65,"line_end":67,"column_start":74,"column_end":6,"is_primary":true,"text":[{"text":"    async fn handle_results(&self, results: Vec<Result<T, E>>) -> Vec<T> {","highlight_start":74,"highlight_end":75},{"text":"        results.into_iter().filter_map(Result::ok).collect()","highlight_start":1,"highlight_end":61},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"...so that the type `T` will meet its required lifetime bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider adding an explicit lifetime bound","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":1892,"byte_end":1892,"line_start":62,"line_end":62,"column_start":15,"column_end":15,"is_primary":true,"text":[{"text":"#[async_trait]","highlight_start":15,"highlight_end":15}],"label":null,"suggested_replacement":", T: 'async_trait","suggestion_applicability":"MaybeIncorrect","expansion":{"span":{"file_name":"src/lib.rs","byte_start":1878,"byte_end":1892,"line_start":62,"line_end":62,"column_start":1,"column_end":15,"is_primary":false,"text":[{"text":"#[async_trait]","highlight_start":1,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[async_trait]","def_site_span":{"file_name":"/Users/dransy/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/async-trait-0.1.88/src/lib.rs","byte_start":7473,"byte_end":7545,"line_start":252,"line_end":252,"column_start":1,"column_end":73,"is_primary":false,"text":[{"text":"pub fn async_trait(args: TokenStream, input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":73}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0309]\u001b[0m\u001b[0m\u001b[1m: the parameter type `T` may not live long enough\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:65:74\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m62\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m#[async_trait]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthe parameter type `T` must be valid for the lifetime `'async_trait` as defined here...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m65\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m    async fn handle_results(&self, results: Vec<Result<T, E>>) -> Vec<T> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m __________________________________________________________________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m66\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        results.into_iter().filter_map(Result::ok).collect()\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m67\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_____^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m...so that the type `T` will meet its required lifetime bounds\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider adding an explicit lifetime bound\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m62\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m#[async_trait]\u001b[0m\u001b[0m\u001b[38;5;10m, T: 'async_trait\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the parameter type `E` may not live long enough","code":{"code":"E0309","explanation":"A parameter type is missing an explicit lifetime bound and may not live long\nenough.\n\nErroneous code example:\n\n```compile_fail,E0309\n// This won't compile because the applicable impl of\n// `SomeTrait` (below) requires that `T: 'a`, but the struct does\n// not have a matching where-clause.\nstruct Foo<'a, T> {\n    foo: <T as SomeTrait<'a>>::Output,\n}\n\ntrait SomeTrait<'a> {\n    type Output;\n}\n\nimpl<'a, T> SomeTrait<'a> for T\nwhere\n    T: 'a,\n{\n    type Output = u32;\n}\n```\n\nThe type definition contains some field whose type requires an outlives\nannotation. Outlives annotations (e.g., `T: 'a`) are used to guarantee that all\nthe data in `T` is valid for at least the lifetime `'a`. This scenario most\ncommonly arises when the type contains an associated type reference like\n`<T as SomeTrait<'a>>::Output`, as shown in the previous code.\n\nThere, the where clause `T: 'a` that appears on the impl is not known to be\nsatisfied on the struct. To make this example compile, you have to add a\nwhere-clause like `T: 'a` to the struct definition:\n\n```\nstruct Foo<'a, T>\nwhere\n    T: 'a,\n{\n    foo: <T as SomeTrait<'a>>::Output\n}\n\ntrait SomeTrait<'a> {\n    type Output;\n}\n\nimpl<'a, T> SomeTrait<'a> for T\nwhere\n    T: 'a,\n{\n    type Output = u32;\n}\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":1878,"byte_end":1892,"line_start":62,"line_end":62,"column_start":1,"column_end":15,"is_primary":false,"text":[{"text":"#[async_trait]","highlight_start":1,"highlight_end":15}],"label":"the parameter type `E` must be valid for the lifetime `'async_trait` as defined here...","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":1878,"byte_end":1892,"line_start":62,"line_end":62,"column_start":1,"column_end":15,"is_primary":false,"text":[{"text":"#[async_trait]","highlight_start":1,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[async_trait]","def_site_span":{"file_name":"/Users/dransy/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/async-trait-0.1.88/src/lib.rs","byte_start":7473,"byte_end":7545,"line_start":252,"line_end":252,"column_start":1,"column_end":73,"is_primary":false,"text":[{"text":"pub fn async_trait(args: TokenStream, input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":73}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":2054,"byte_end":2122,"line_start":65,"line_end":67,"column_start":74,"column_end":6,"is_primary":true,"text":[{"text":"    async fn handle_results(&self, results: Vec<Result<T, E>>) -> Vec<T> {","highlight_start":74,"highlight_end":75},{"text":"        results.into_iter().filter_map(Result::ok).collect()","highlight_start":1,"highlight_end":61},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"...so that the type `E` will meet its required lifetime bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider adding an explicit lifetime bound","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":1892,"byte_end":1892,"line_start":62,"line_end":62,"column_start":15,"column_end":15,"is_primary":true,"text":[{"text":"#[async_trait]","highlight_start":15,"highlight_end":15}],"label":null,"suggested_replacement":", E: 'async_trait","suggestion_applicability":"MaybeIncorrect","expansion":{"span":{"file_name":"src/lib.rs","byte_start":1878,"byte_end":1892,"line_start":62,"line_end":62,"column_start":1,"column_end":15,"is_primary":false,"text":[{"text":"#[async_trait]","highlight_start":1,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[async_trait]","def_site_span":{"file_name":"/Users/dransy/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/async-trait-0.1.88/src/lib.rs","byte_start":7473,"byte_end":7545,"line_start":252,"line_end":252,"column_start":1,"column_end":73,"is_primary":false,"text":[{"text":"pub fn async_trait(args: TokenStream, input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":73}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0309]\u001b[0m\u001b[0m\u001b[1m: the parameter type `E` may not live long enough\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:65:74\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m62\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m#[async_trait]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthe parameter type `E` must be valid for the lifetime `'async_trait` as defined here...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m65\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m    async fn handle_results(&self, results: Vec<Result<T, E>>) -> Vec<T> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m __________________________________________________________________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m66\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        results.into_iter().filter_map(Result::ok).collect()\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m67\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_____^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m...so that the type `E` will meet its required lifetime bounds\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider adding an explicit lifetime bound\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m62\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m#[async_trait]\u001b[0m\u001b[0m\u001b[38;5;10m, E: 'async_trait\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the parameter type `T` may not live long enough","code":{"code":"E0309","explanation":"A parameter type is missing an explicit lifetime bound and may not live long\nenough.\n\nErroneous code example:\n\n```compile_fail,E0309\n// This won't compile because the applicable impl of\n// `SomeTrait` (below) requires that `T: 'a`, but the struct does\n// not have a matching where-clause.\nstruct Foo<'a, T> {\n    foo: <T as SomeTrait<'a>>::Output,\n}\n\ntrait SomeTrait<'a> {\n    type Output;\n}\n\nimpl<'a, T> SomeTrait<'a> for T\nwhere\n    T: 'a,\n{\n    type Output = u32;\n}\n```\n\nThe type definition contains some field whose type requires an outlives\nannotation. Outlives annotations (e.g., `T: 'a`) are used to guarantee that all\nthe data in `T` is valid for at least the lifetime `'a`. This scenario most\ncommonly arises when the type contains an associated type reference like\n`<T as SomeTrait<'a>>::Output`, as shown in the previous code.\n\nThere, the where clause `T: 'a` that appears on the impl is not known to be\nsatisfied on the struct. To make this example compile, you have to add a\nwhere-clause like `T: 'a` to the struct definition:\n\n```\nstruct Foo<'a, T>\nwhere\n    T: 'a,\n{\n    foo: <T as SomeTrait<'a>>::Output\n}\n\ntrait SomeTrait<'a> {\n    type Output;\n}\n\nimpl<'a, T> SomeTrait<'a> for T\nwhere\n    T: 'a,\n{\n    type Output = u32;\n}\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":2178,"byte_end":2192,"line_start":72,"line_end":72,"column_start":1,"column_end":15,"is_primary":false,"text":[{"text":"#[async_trait]","highlight_start":1,"highlight_end":15}],"label":"the parameter type `T` must be valid for the lifetime `'async_trait` as defined here...","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":2178,"byte_end":2192,"line_start":72,"line_end":72,"column_start":1,"column_end":15,"is_primary":false,"text":[{"text":"#[async_trait]","highlight_start":1,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[async_trait]","def_site_span":{"file_name":"/Users/dransy/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/async-trait-0.1.88/src/lib.rs","byte_start":7473,"byte_end":7545,"line_start":252,"line_end":252,"column_start":1,"column_end":73,"is_primary":false,"text":[{"text":"pub fn async_trait(args: TokenStream, input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":73}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":2377,"byte_end":2400,"line_start":75,"line_end":77,"column_start":85,"column_end":6,"is_primary":true,"text":[{"text":"    async fn handle_results(&self, results: Vec<Result<T, E>>) -> Vec<Result<T, E>> {","highlight_start":85,"highlight_end":86},{"text":"        results","highlight_start":1,"highlight_end":16},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"...so that the type `T` will meet its required lifetime bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider adding an explicit lifetime bound","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":2192,"byte_end":2192,"line_start":72,"line_end":72,"column_start":15,"column_end":15,"is_primary":true,"text":[{"text":"#[async_trait]","highlight_start":15,"highlight_end":15}],"label":null,"suggested_replacement":", T: 'async_trait","suggestion_applicability":"MaybeIncorrect","expansion":{"span":{"file_name":"src/lib.rs","byte_start":2178,"byte_end":2192,"line_start":72,"line_end":72,"column_start":1,"column_end":15,"is_primary":false,"text":[{"text":"#[async_trait]","highlight_start":1,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[async_trait]","def_site_span":{"file_name":"/Users/dransy/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/async-trait-0.1.88/src/lib.rs","byte_start":7473,"byte_end":7545,"line_start":252,"line_end":252,"column_start":1,"column_end":73,"is_primary":false,"text":[{"text":"pub fn async_trait(args: TokenStream, input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":73}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0309]\u001b[0m\u001b[0m\u001b[1m: the parameter type `T` may not live long enough\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:75:85\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m72\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m#[async_trait]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthe parameter type `T` must be valid for the lifetime `'async_trait` as defined here...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m75\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m    async fn handle_results(&self, results: Vec<Result<T, E>>) -> Vec<Result<T, E>> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m _____________________________________________________________________________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m76\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        results\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m77\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_____^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m...so that the type `T` will meet its required lifetime bounds\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider adding an explicit lifetime bound\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m72\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m#[async_trait]\u001b[0m\u001b[0m\u001b[38;5;10m, T: 'async_trait\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the parameter type `E` may not live long enough","code":{"code":"E0309","explanation":"A parameter type is missing an explicit lifetime bound and may not live long\nenough.\n\nErroneous code example:\n\n```compile_fail,E0309\n// This won't compile because the applicable impl of\n// `SomeTrait` (below) requires that `T: 'a`, but the struct does\n// not have a matching where-clause.\nstruct Foo<'a, T> {\n    foo: <T as SomeTrait<'a>>::Output,\n}\n\ntrait SomeTrait<'a> {\n    type Output;\n}\n\nimpl<'a, T> SomeTrait<'a> for T\nwhere\n    T: 'a,\n{\n    type Output = u32;\n}\n```\n\nThe type definition contains some field whose type requires an outlives\nannotation. Outlives annotations (e.g., `T: 'a`) are used to guarantee that all\nthe data in `T` is valid for at least the lifetime `'a`. This scenario most\ncommonly arises when the type contains an associated type reference like\n`<T as SomeTrait<'a>>::Output`, as shown in the previous code.\n\nThere, the where clause `T: 'a` that appears on the impl is not known to be\nsatisfied on the struct. To make this example compile, you have to add a\nwhere-clause like `T: 'a` to the struct definition:\n\n```\nstruct Foo<'a, T>\nwhere\n    T: 'a,\n{\n    foo: <T as SomeTrait<'a>>::Output\n}\n\ntrait SomeTrait<'a> {\n    type Output;\n}\n\nimpl<'a, T> SomeTrait<'a> for T\nwhere\n    T: 'a,\n{\n    type Output = u32;\n}\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":2178,"byte_end":2192,"line_start":72,"line_end":72,"column_start":1,"column_end":15,"is_primary":false,"text":[{"text":"#[async_trait]","highlight_start":1,"highlight_end":15}],"label":"the parameter type `E` must be valid for the lifetime `'async_trait` as defined here...","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":2178,"byte_end":2192,"line_start":72,"line_end":72,"column_start":1,"column_end":15,"is_primary":false,"text":[{"text":"#[async_trait]","highlight_start":1,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[async_trait]","def_site_span":{"file_name":"/Users/dransy/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/async-trait-0.1.88/src/lib.rs","byte_start":7473,"byte_end":7545,"line_start":252,"line_end":252,"column_start":1,"column_end":73,"is_primary":false,"text":[{"text":"pub fn async_trait(args: TokenStream, input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":73}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":2377,"byte_end":2400,"line_start":75,"line_end":77,"column_start":85,"column_end":6,"is_primary":true,"text":[{"text":"    async fn handle_results(&self, results: Vec<Result<T, E>>) -> Vec<Result<T, E>> {","highlight_start":85,"highlight_end":86},{"text":"        results","highlight_start":1,"highlight_end":16},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"...so that the type `E` will meet its required lifetime bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider adding an explicit lifetime bound","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":2192,"byte_end":2192,"line_start":72,"line_end":72,"column_start":15,"column_end":15,"is_primary":true,"text":[{"text":"#[async_trait]","highlight_start":15,"highlight_end":15}],"label":null,"suggested_replacement":", E: 'async_trait","suggestion_applicability":"MaybeIncorrect","expansion":{"span":{"file_name":"src/lib.rs","byte_start":2178,"byte_end":2192,"line_start":72,"line_end":72,"column_start":1,"column_end":15,"is_primary":false,"text":[{"text":"#[async_trait]","highlight_start":1,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[async_trait]","def_site_span":{"file_name":"/Users/dransy/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/async-trait-0.1.88/src/lib.rs","byte_start":7473,"byte_end":7545,"line_start":252,"line_end":252,"column_start":1,"column_end":73,"is_primary":false,"text":[{"text":"pub fn async_trait(args: TokenStream, input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":73}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0309]\u001b[0m\u001b[0m\u001b[1m: the parameter type `E` may not live long enough\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:75:85\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m72\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m#[async_trait]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthe parameter type `E` must be valid for the lifetime `'async_trait` as defined here...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m75\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m    async fn handle_results(&self, results: Vec<Result<T, E>>) -> Vec<Result<T, E>> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m _____________________________________________________________________________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m76\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        results\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m77\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_____^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m...so that the type `E` will meet its required lifetime bounds\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider adding an explicit lifetime bound\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m72\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m#[async_trait]\u001b[0m\u001b[0m\u001b[38;5;10m, E: 'async_trait\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the parameter type `T` may not live long enough","code":{"code":"E0309","explanation":"A parameter type is missing an explicit lifetime bound and may not live long\nenough.\n\nErroneous code example:\n\n```compile_fail,E0309\n// This won't compile because the applicable impl of\n// `SomeTrait` (below) requires that `T: 'a`, but the struct does\n// not have a matching where-clause.\nstruct Foo<'a, T> {\n    foo: <T as SomeTrait<'a>>::Output,\n}\n\ntrait SomeTrait<'a> {\n    type Output;\n}\n\nimpl<'a, T> SomeTrait<'a> for T\nwhere\n    T: 'a,\n{\n    type Output = u32;\n}\n```\n\nThe type definition contains some field whose type requires an outlives\nannotation. Outlives annotations (e.g., `T: 'a`) are used to guarantee that all\nthe data in `T` is valid for at least the lifetime `'a`. This scenario most\ncommonly arises when the type contains an associated type reference like\n`<T as SomeTrait<'a>>::Output`, as shown in the previous code.\n\nThere, the where clause `T: 'a` that appears on the impl is not known to be\nsatisfied on the struct. To make this example compile, you have to add a\nwhere-clause like `T: 'a` to the struct definition:\n\n```\nstruct Foo<'a, T>\nwhere\n    T: 'a,\n{\n    foo: <T as SomeTrait<'a>>::Output\n}\n\ntrait SomeTrait<'a> {\n    type Output;\n}\n\nimpl<'a, T> SomeTrait<'a> for T\nwhere\n    T: 'a,\n{\n    type Output = u32;\n}\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":2455,"byte_end":2469,"line_start":82,"line_end":82,"column_start":1,"column_end":15,"is_primary":false,"text":[{"text":"#[async_trait]","highlight_start":1,"highlight_end":15}],"label":"the parameter type `T` must be valid for the lifetime `'async_trait` as defined here...","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":2455,"byte_end":2469,"line_start":82,"line_end":82,"column_start":1,"column_end":15,"is_primary":false,"text":[{"text":"#[async_trait]","highlight_start":1,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[async_trait]","def_site_span":{"file_name":"/Users/dransy/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/async-trait-0.1.88/src/lib.rs","byte_start":7473,"byte_end":7545,"line_start":252,"line_end":252,"column_start":1,"column_end":73,"is_primary":false,"text":[{"text":"pub fn async_trait(args: TokenStream, input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":73}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":2655,"byte_end":2900,"line_start":85,"line_end":94,"column_start":85,"column_end":6,"is_primary":true,"text":[{"text":"    async fn handle_results(&self, results: Vec<Result<T, E>>) -> Result<Vec<T>, E> {","highlight_start":85,"highlight_end":86},{"text":"        let mut successes = Vec::new();","highlight_start":1,"highlight_end":40},{"text":"        for result in results {","highlight_start":1,"highlight_end":32},{"text":"            match result {","highlight_start":1,"highlight_end":27},{"text":"                Ok(value) => successes.push(value),","highlight_start":1,"highlight_end":52},{"text":"                Err(e) => return Err(e),","highlight_start":1,"highlight_end":41},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        Ok(successes)","highlight_start":1,"highlight_end":22},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"...so that the type `T` will meet its required lifetime bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider adding an explicit lifetime bound","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":2469,"byte_end":2469,"line_start":82,"line_end":82,"column_start":15,"column_end":15,"is_primary":true,"text":[{"text":"#[async_trait]","highlight_start":15,"highlight_end":15}],"label":null,"suggested_replacement":", T: 'async_trait","suggestion_applicability":"MaybeIncorrect","expansion":{"span":{"file_name":"src/lib.rs","byte_start":2455,"byte_end":2469,"line_start":82,"line_end":82,"column_start":1,"column_end":15,"is_primary":false,"text":[{"text":"#[async_trait]","highlight_start":1,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[async_trait]","def_site_span":{"file_name":"/Users/dransy/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/async-trait-0.1.88/src/lib.rs","byte_start":7473,"byte_end":7545,"line_start":252,"line_end":252,"column_start":1,"column_end":73,"is_primary":false,"text":[{"text":"pub fn async_trait(args: TokenStream, input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":73}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0309]\u001b[0m\u001b[0m\u001b[1m: the parameter type `T` may not live long enough\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:85:85\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m82\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m#[async_trait]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthe parameter type `T` must be valid for the lifetime `'async_trait` as defined here...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m85\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m    async fn handle_results(&self, results: Vec<Result<T, E>>) -> Result<Vec<T>, E> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m _____________________________________________________________________________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m86\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let mut successes = Vec::new();\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m87\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        for result in results {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m88\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            match result {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m93\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        Ok(successes)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m94\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_____^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m...so that the type `T` will meet its required lifetime bounds\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider adding an explicit lifetime bound\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m82\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m#[async_trait]\u001b[0m\u001b[0m\u001b[38;5;10m, T: 'async_trait\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the parameter type `E` may not live long enough","code":{"code":"E0309","explanation":"A parameter type is missing an explicit lifetime bound and may not live long\nenough.\n\nErroneous code example:\n\n```compile_fail,E0309\n// This won't compile because the applicable impl of\n// `SomeTrait` (below) requires that `T: 'a`, but the struct does\n// not have a matching where-clause.\nstruct Foo<'a, T> {\n    foo: <T as SomeTrait<'a>>::Output,\n}\n\ntrait SomeTrait<'a> {\n    type Output;\n}\n\nimpl<'a, T> SomeTrait<'a> for T\nwhere\n    T: 'a,\n{\n    type Output = u32;\n}\n```\n\nThe type definition contains some field whose type requires an outlives\nannotation. Outlives annotations (e.g., `T: 'a`) are used to guarantee that all\nthe data in `T` is valid for at least the lifetime `'a`. This scenario most\ncommonly arises when the type contains an associated type reference like\n`<T as SomeTrait<'a>>::Output`, as shown in the previous code.\n\nThere, the where clause `T: 'a` that appears on the impl is not known to be\nsatisfied on the struct. To make this example compile, you have to add a\nwhere-clause like `T: 'a` to the struct definition:\n\n```\nstruct Foo<'a, T>\nwhere\n    T: 'a,\n{\n    foo: <T as SomeTrait<'a>>::Output\n}\n\ntrait SomeTrait<'a> {\n    type Output;\n}\n\nimpl<'a, T> SomeTrait<'a> for T\nwhere\n    T: 'a,\n{\n    type Output = u32;\n}\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":2455,"byte_end":2469,"line_start":82,"line_end":82,"column_start":1,"column_end":15,"is_primary":false,"text":[{"text":"#[async_trait]","highlight_start":1,"highlight_end":15}],"label":"the parameter type `E` must be valid for the lifetime `'async_trait` as defined here...","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":2455,"byte_end":2469,"line_start":82,"line_end":82,"column_start":1,"column_end":15,"is_primary":false,"text":[{"text":"#[async_trait]","highlight_start":1,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[async_trait]","def_site_span":{"file_name":"/Users/dransy/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/async-trait-0.1.88/src/lib.rs","byte_start":7473,"byte_end":7545,"line_start":252,"line_end":252,"column_start":1,"column_end":73,"is_primary":false,"text":[{"text":"pub fn async_trait(args: TokenStream, input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":73}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":2655,"byte_end":2900,"line_start":85,"line_end":94,"column_start":85,"column_end":6,"is_primary":true,"text":[{"text":"    async fn handle_results(&self, results: Vec<Result<T, E>>) -> Result<Vec<T>, E> {","highlight_start":85,"highlight_end":86},{"text":"        let mut successes = Vec::new();","highlight_start":1,"highlight_end":40},{"text":"        for result in results {","highlight_start":1,"highlight_end":32},{"text":"            match result {","highlight_start":1,"highlight_end":27},{"text":"                Ok(value) => successes.push(value),","highlight_start":1,"highlight_end":52},{"text":"                Err(e) => return Err(e),","highlight_start":1,"highlight_end":41},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        Ok(successes)","highlight_start":1,"highlight_end":22},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"...so that the type `E` will meet its required lifetime bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider adding an explicit lifetime bound","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":2469,"byte_end":2469,"line_start":82,"line_end":82,"column_start":15,"column_end":15,"is_primary":true,"text":[{"text":"#[async_trait]","highlight_start":15,"highlight_end":15}],"label":null,"suggested_replacement":", E: 'async_trait","suggestion_applicability":"MaybeIncorrect","expansion":{"span":{"file_name":"src/lib.rs","byte_start":2455,"byte_end":2469,"line_start":82,"line_end":82,"column_start":1,"column_end":15,"is_primary":false,"text":[{"text":"#[async_trait]","highlight_start":1,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[async_trait]","def_site_span":{"file_name":"/Users/dransy/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/async-trait-0.1.88/src/lib.rs","byte_start":7473,"byte_end":7545,"line_start":252,"line_end":252,"column_start":1,"column_end":73,"is_primary":false,"text":[{"text":"pub fn async_trait(args: TokenStream, input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":73}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0309]\u001b[0m\u001b[0m\u001b[1m: the parameter type `E` may not live long enough\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:85:85\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m82\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m#[async_trait]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthe parameter type `E` must be valid for the lifetime `'async_trait` as defined here...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m85\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m    async fn handle_results(&self, results: Vec<Result<T, E>>) -> Result<Vec<T>, E> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m _____________________________________________________________________________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m86\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let mut successes = Vec::new();\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m87\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        for result in results {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m88\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            match result {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m93\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        Ok(successes)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m94\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_____^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m...so that the type `E` will meet its required lifetime bounds\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider adding an explicit lifetime bound\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m82\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m#[async_trait]\u001b[0m\u001b[0m\u001b[38;5;10m, E: 'async_trait\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `fn_name`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/lib.rs","byte_start":3923,"byte_end":3930,"line_start":136,"line_end":136,"column_start":33,"column_end":40,"is_primary":true,"text":[{"text":"pub fn register_function_config(fn_name: &str, config: FunctionConfig) {","highlight_start":33,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":3923,"byte_end":3930,"line_start":136,"line_end":136,"column_start":33,"column_end":40,"is_primary":true,"text":[{"text":"pub fn register_function_config(fn_name: &str, config: FunctionConfig) {","highlight_start":33,"highlight_end":40}],"label":null,"suggested_replacement":"_fn_name","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused variable: `fn_name`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:136:33\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m136\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn register_function_config(fn_name: &str, config: FunctionConfig) {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_fn_name`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `config`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/lib.rs","byte_start":3938,"byte_end":3944,"line_start":136,"line_end":136,"column_start":48,"column_end":54,"is_primary":true,"text":[{"text":"pub fn register_function_config(fn_name: &str, config: FunctionConfig) {","highlight_start":48,"highlight_end":54}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":3938,"byte_end":3944,"line_start":136,"line_end":136,"column_start":48,"column_end":54,"is_primary":true,"text":[{"text":"pub fn register_function_config(fn_name: &str, config: FunctionConfig) {","highlight_start":48,"highlight_end":54}],"label":null,"suggested_replacement":"_config","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused variable: `config`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:136:48\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m136\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn register_function_config(fn_name: &str, config: FunctionConfig) {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_config`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 22 previous errors; 5 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 22 previous errors; 5 warnings emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0015, E0277, E0308, E0309, E0432, E0433, E0609, E0659.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mSome errors have detailed explanations: E0015, E0277, E0308, E0309, E0432, E0433, E0609, E0659.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0015`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about an error, try `rustc --explain E0015`.\u001b[0m\n"}
